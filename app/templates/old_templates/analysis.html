{% extends "base.html" %}

{% block title %}
    {% if exercise_config %}
        An√°lisis de {{ exercise_config.exercise_name }} - {{ exercise_config.segment_name }} - BioTrack
    {% else %}
        An√°lisis de {{ joint_config.name }} - BioTrack
    {% endif %}
{% endblock %}

{% block content %}
<!-- ‚úÖ MANTENER toda la estructura HTML existente -->
<div class="container-fluid">
    
    <div id="initialMessage" class="text-center py-5">
        <div class="biomech-glass p-5">
            <div class="analysis-header mb-4">
                {% if exercise_config %}
                    <!-- ‚úÖ Header din√°mico con informaci√≥n del ejercicio -->
                    <div class="exercise-info">
                        <div class="d-flex align-items-center justify-content-center mb-3">
                            <i class="bi bi-{{ exercise_config.segment_icon|default('circle') }}" style="font-size: 2rem; color: var(--biomech-cyan); margin-right: 1rem;"></i>
                            <div>
                                <h2 class="mb-1">{{ exercise_config.exercise_name }}</h2>
                            </div>
                        </div>
                        
                        <div class="exercise-details">
                            <div class="row mt-3">
                                <div class="col-md-4">
                                    <div class="info-badge">
                                        <small class="text-muted">Dificultad</small>
                                        <span class="badge bg-{{ 'success' if exercise_config.difficulty == 'easy' else 'warning' if exercise_config.difficulty == 'medium' else 'danger' }}">
                                            {{ exercise_config.difficulty|title }}
                                        </span>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="info-badge">
                                        <small class="text-muted">Rango Normal Articulaci√≥n</small>
                                        <span class="fw-bold">{{ exercise_config.normal_range.min }}¬∞ - {{ exercise_config.normal_range.max }}¬∞</span>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="info-badge">
                                        <small class="text-muted">Plano</small>
                                        <span class="fw-bold">{{ exercise_config.plane|title }}</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                {% else %}
                    <!-- ‚úÖ FALLBACK: Header legacy -->
                    <h2>{{ joint_config.name }}</h2>
                {% endif %}
            </div>
            
            <div class="hero-content">
                <div class="hero-icon mb-4">
                    <i class="bi bi-camera-video biomech-icon"></i>
                </div>
                <h3>Presiona "Iniciar An√°lisis" para comenzar</h3>
                <!--p class="text-secondary">El sistema detectar√° autom√°ticamente la mejor c√°mara disponible</p -->
                
                {% if exercise_config and exercise_config.instructions %}
                    <!-- ‚úÖ NUEVO: Instrucciones espec√≠ficas del ejercicio -->
                    <div class="instructions-preview mt-4">
                        <div class="biomech-glass p-3">
                            <h5><i class="bi bi-info-circle me-2"></i>Instrucciones del Ejercicio</h5>
                            <div class="row text-start">
                                <div class="col-md-6">
                                    <strong>Posici√≥n inicial:</strong>
                                    <p class="small">{{ exercise_config.instructions.position|default('Siga las indicaciones en pantalla') }}</p>
                                </div>
                                <div class="col-md-6">
                                    <strong>Movimiento:</strong>
                                    <p class="small">{{ exercise_config.instructions.movement|default('Realice el movimiento lentamente') }}</p>
                                </div>
                            </div>
                            {% if exercise_config.instructions.warning %}
                                <div class="alert alert-warning alert-sm mt-2">
                                    <i class="bi bi-exclamation-triangle me-2"></i>
                                    {{ exercise_config.instructions.warning }}
                                </div>
                            {% endif %}
                        </div>
                    </div>
                {% endif %}
            </div>
            
            <div class="hero-actions">
                <!-- üé® SESSION 3: Contenedor de mensajes de estado SIEMPRE VISIBLE -->
                <div id="camera-status-container" style="
                    position: fixed;
                    top: 80px;
                    left: 50%;
                    transform: translateX(-50%);
                    z-index: 10000;
                    width: 90%;
                    max-width: 600px;
                    pointer-events: none;
                ">
                    <!-- Mensaje de estado -->
                    <div id="camera-status-message" style="display: none; pointer-events: auto;"></div>
                    
                    <!-- Bot√≥n de retry (se crea din√°micamente) - FIXED POSITION -->
                    <div id="camera-retry-container" style="
                        position: fixed;
                        top: 160px;
                        left: 50%;
                        transform: translateX(-50%);
                        z-index: 10001;
                        pointer-events: auto;
                        text-align: center;
                    "></div>
                </div>
                
                <!-- Bot√≥n principal centrado (sin navegaci√≥n aqu√≠, ya est√° arriba) -->
                <button id="startAnalysisBtn" class="hero-button primary" disabled style="opacity: 0.5; cursor: wait;">
                    <i class="bi bi-hourglass-split"></i>
                    Detectando c√°maras...
                </button>
                
                <div id="runningButtons" style="display: none;">
                    <button id="pauseAnalysisBtn" class="hero-button secondary" onclick="pauseAnalysis()">
                        <i class="bi bi-pause-circle"></i>
                        Pausar An√°lisis
                    </button>
                    <button id="stopAnalysisBtn" class="hero-button danger" onclick="stopAnalysisCompletely()">
                        <i class="bi bi-stop-circle"></i>
                        Detener Completamente
                    </button>
                </div>
            </div>
            
            <div class="mt-4">
                <small class="text-muted">
                    <i class="bi bi-shield-check me-1"></i>
                    An√°lisis seguro y no invasivo mediante inteligencia artificial
                </small>
            </div>
        </div>
    </div>

    <!-- ‚öôÔ∏è BOTON FLOTANTE CONFIGURACION CAMARA -->
    <button id="cameraSettingsBtn" class="floating-camera-settings-btn" 
            onclick="openCameraSettings()" 
            title="Configurar C√°mara">
        <i class="bi bi-gear-fill"></i>
    </button>

    <!-- üîä BOTON FLOTANTE AUDIO TOGGLE -->
    <button id="audioToggleBtn" class="floating-audio-toggle-btn" 
            onclick="toggleAudioGuide()" 
            title="Activar/Desactivar Audio">
        <i class="bi bi-volume-up-fill" id="audioIcon"></i>
    </button>

    <!-- üîç BOTON FLOTANTE DEBUG (SOLO ADMIN) -->
    {% if session.role == 'admin' %}
    <button id="debugToggleBtn" class="floating-debug-toggle-btn" 
            onclick="toggleDebugPanel()" 
            title="Panel de Debug (Admin)">
        <i class="bi bi-bug-fill"></i>
    </button>
    {% endif %}

    <!-- üÜï ROM SESSION CONTAINER -->
    <div id="rom-session-container" style="display: none;">
        <!-- ROM Session UI ser√° inyectado aqu√≠ por JavaScript -->
    </div>

    <!-- üîç DEBUG PANEL (SOLO ADMIN) -->
    {% if session.role == 'admin' %}
    <div id="debugPanel" class="debug-panel" style="display: none;">
        <div class="debug-panel-header">
            <h5>
                <i class="bi bi-bug-fill me-2"></i>
                Panel de Debug de √Ångulos
                <span class="badge bg-danger ms-2">ADMIN</span>
            </h5>
            <button class="btn-close btn-close-white" onclick="toggleDebugPanel()"></button>
        </div>
        
        <div class="debug-panel-body">
            <div class="alert alert-info alert-sm mb-3">
                <i class="bi bi-info-circle me-2"></i>
                <strong>Modo Debug:</strong> Valida precisi√≥n de mediciones de √°ngulos comparando con goni√≥metro f√≠sico.
            </div>

            <!-- Estado del Debug -->
            <div class="debug-status mb-3">
                <div class="d-flex justify-content-between align-items-center">
                    <span>
                        <i class="bi bi-circle-fill" id="debugStatusIcon" style="color: #666;"></i>
                        <span id="debugStatusText">Debug Inactivo</span>
                    </span>
                    <button id="debugToggleButton" class="btn btn-sm btn-outline-primary" onclick="toggleDebugMode()">
                        <i class="bi bi-play-fill"></i> Activar Debug
                    </button>
                </div>
            </div>

            <!-- Informaci√≥n del segmento actual -->
            <div class="debug-info mb-3">
                <small class="text-muted">
                    <strong>Segmento:</strong> <span id="debugSegment">-</span><br>
                    <strong>Ejercicio:</strong> <span id="debugExercise">-</span>
                </small>
            </div>

            <hr class="my-3">

            <!-- Botones de captura -->
            <div class="debug-actions">
                <button class="btn btn-success btn-sm w-100 mb-2" onclick="captureDebugSnapshot()" id="captureBtn" disabled>
                    <i class="bi bi-camera-fill me-2"></i>
                    Capturar Snapshot
                </button>
                
                <button class="btn btn-warning btn-sm w-100" onclick="captureWithManualAngle()" id="captureManualBtn" disabled>
                    <i class="bi bi-pencil-square me-2"></i>
                    Capturar + √Ångulo Manual
                </button>
            </div>

            <!-- √öltimo resultado -->
            <div id="debugLastResult" class="debug-result mt-3" style="display: none;">
                <hr class="my-3">
                <h6><i class="bi bi-check-circle me-2"></i>√öltimo Snapshot</h6>
                <div id="debugResultContent"></div>
            </div>

            <!-- Ayuda -->
            <div class="mt-3">
                <small class="text-muted">
                    <i class="bi bi-lightbulb me-1"></i>
                    <strong>Instrucciones:</strong><br>
                    1. Activa el debug mode<br>
                    2. <strong>Inicia el an√°lisis</strong> (bot√≥n verde)<br>
                    3. Realiza el movimiento<br>
                    4. Mide con goni√≥metro f√≠sico<br>
                    5. Captura con √°ngulo manual<br>
                    6. Revisa carpeta debug_angles/
                </small>
            </div>
        </div>
    </div>
    {% endif %}

    <!-- üé¨ MODAL FULLSCREEN PARA STREAM DE AN√ÅLISIS -->
    <div id="analysisModal" class="analysis-modal">
        <div class="analysis-modal-content">
            <!-- Bot√≥n cerrar manual -->
            <button class="analysis-close-btn" onclick="closeAnalysisModalManual(event)">
                <i class="bi bi-x-lg"></i>
            </button>
            
            <!-- Stream Container (movido aqu√≠ durante an√°lisis) -->
            <div id="modalStreamContainer" class="modal-stream-wrapper">
                <!-- El stream se mover√° aqu√≠ din√°micamente -->
            </div>
        </div>
    </div>

    <!-- ‚úÖ MANTENER toda la estructura de an√°lisis existente -->
    <div id="analysisInterface" style="display: none;">
        <div class="row">
            <!-- Panel de Stream -->
            <div class="col-lg-8">
                <div class="analysis-panel">
                    <div class="panel-header">
                        <h3><i class="bi bi-camera-video"></i> An√°lisis en Tiempo Real</h3>
                        <div id="analysisStatus" class="status-badge">Preparando...</div>
                    </div>
                    
                    <!-- Stream Container -->
                    <div class="stream-container" style="position: relative; background-color: #000000; min-height: 400px; border-radius: 8px;">
                        
                        <!-- üÜï BOT√ìN INICIAR AN√ÅLISIS MANUAL - ENCIMA DE TODO -->
                        <div id="manualStartButton" style="
                            position: absolute;
                            top: 20px;
                            left: 50%;
                            transform: translateX(-50%);
                            z-index: 1000;
                            display: none;
                        ">
                            <button onclick="startManualAnalysis()" style="
                                background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
                                color: white;
                                border: none;
                                padding: 20px 40px;
                                font-size: 24px;
                                font-weight: bold;
                                border-radius: 15px;
                                cursor: pointer;
                                box-shadow: 0 8px 20px rgba(40, 167, 69, 0.4);
                                transition: all 0.3s ease;
                                display: flex;
                                align-items: center;
                                gap: 15px;
                            " 
                            onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 12px 30px rgba(40, 167, 69, 0.6)'"
                            onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 8px 20px rgba(40, 167, 69, 0.4)'">
                                <i class="bi bi-play-circle-fill" style="font-size: 32px;"></i>
                                <span>INICIAR AN√ÅLISIS</span>
                            </button>
                        </div>
                        
                        <img id="analysisStream" 
                             class="analysis-stream"
                             style="width: 100%; height: auto; border-radius: 8px; display: none;"
                             alt="Stream de an√°lisis biomec√°nico">
                        
                        <!-- üÜï ROM OVERLAY INTEGRADO -->
                        <div id="romOverlay" style="
                            position: absolute; 
                            top: 10px; 
                            right: 10px; 
                            background: rgba(0,0,0,0.8); 
                            border-radius: 10px; 
                            padding: 15px; 
                            color: white; 
                            font-family: 'Courier New', monospace;
                            min-width: 200px;
                            display: block;
                            z-index: 10;
                        ">
                            <div style="text-align: center; border-bottom: 1px solid #444; padding-bottom: 8px; margin-bottom: 8px;">
                                <strong style="color: #007bff;">ROM TRACKING</strong>
                            </div>
                            
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <span>Actual:</span>
                                <span id="romCurrentAngle" style="color: #28a745; font-weight: bold;">0¬∞</span>
                            </div>
                            
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span>M√°ximo:</span>
                                <span id="romMaxAngle" style="color: #ffc107; font-weight: bold;">0¬∞</span>
                            </div>
                            
                            <!-- üÜï Estado separado para mensajes del sistema -->
                            <div id="romStatusMessage" style="
                                text-align: center; 
                                color: #28a745; 
                                font-weight: bold; 
                                font-size: 12px;
                                display: none;
                                margin-top: 5px;
                                padding: 3px;
                                background: rgba(40, 167, 69, 0.1);
                                border-radius: 3px;
                            "></div>
                            
                            <!-- Timer compacto -->
                            <div id="romTimerCompact" style="
                                text-align: center; 
                                background: #007bff; 
                                border-radius: 5px; 
                                padding: 5px; 
                                display: none;
                            ">
                                <div style="font-size: 24px; font-weight: bold;" id="romTimerSeconds">{{ exercise_config.duration_seconds if exercise_config and exercise_config.duration_seconds else 14 }}</div>
                                <div style="font-size: 10px;">segundos</div>
                            </div>
                        </div>
                        
                        <!-- Loading Message -->
                        <div id="loadingMessage" class="text-center py-5" style="display: block; color: white;">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Cargando...</span>
                            </div>
                            <p class="mt-3">Iniciando an√°lisis...</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Panel de Informaci√≥n -->
            <div class="col-lg-4">
                <!-- Informaci√≥n del Ejercicio -->
                <div class="info-panel mb-4">
                    <h4><i class="bi bi-info-circle"></i> Informaci√≥n</h4>
                    <div class="exercise-info">
                        {% if exercise_config and exercise_config.instructions %}
                            <p><strong>Posici√≥n:</strong> {{ exercise_config.instructions.position }}</p>
                            <p><strong>Movimiento:</strong> {{ exercise_config.instructions.movement }}</p>
                            <div class="alert alert-warning">
                                <i class="bi bi-exclamation-triangle"></i>
                                {{ exercise_config.instructions.warning }}
                            </div>
                        {% else %}
                            <p><strong>Posici√≥n:</strong> {{ joint_config.instructions.position }}</p>
                            <p><strong>Movimiento:</strong> {{ joint_config.instructions.movement }}</p>
                            <div class="alert alert-warning">
                                <i class="bi bi-exclamation-triangle"></i>
                                {{ joint_config.instructions.warning }}
                            </div>
                        {% endif %}
                    </div>
                </div>

                <!-- Estad√≠sticas en Tiempo Real -->
                <div class="stats-panel">
                    <h4><i class="bi bi-graph-up"></i> Estado del An√°lisis</h4>
                    <div class="stat-item">
                        <div class="stat-label">Rango Normal</div>
                        <div class="stat-value">
                            {% if exercise_config %}
                                {{ exercise_config.normal_range.min }}¬∞ - {{ exercise_config.normal_range.max }}¬∞
                            {% else %}
                                {{ joint_config.normal_range.min }}¬∞ - {{ joint_config.normal_range.max }}¬∞
                            {% endif %}
                        </div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Estado del Stream</div>
                        <div class="stat-value" id="streamStatus">Inactivo</div>
                    </div>
                </div>

                <!-- ‚úÖ BOTONES DE ACCI√ìN MEJORADOS -->
                <div class="action-panel mt-4">
                    <div class="row g-2">
                        <div class="col-6">
                            <button onclick="saveAnalysis()" class="btn btn-success w-100">
                                <i class="bi bi-save"></i> Guardar
                            </button>
                        </div>
                        <div class="col-6">
                            <button onclick="resetAnalysis()" class="btn btn-warning w-100">
                                <i class="bi bi-arrow-clockwise"></i> Reiniciar
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- üÜï NAVEGACI√ìN DE EJERCICIOS (entre c√°mara e historial) -->
<div class="container-fluid px-4">
    <div class="global-exercise-navigation mt-2 mb-3">
        <div class="biomech-glass p-3" style="overflow: visible; position: relative; z-index: 100;">
            <div class="exercise-nav-container">
                <!-- IZQUIERDA: Anterior -->
                <a href="#" id="prevExerciseBtn" class="nav-exercise-link nav-left" style="visibility: hidden;">
                    <i class="bi bi-arrow-left-circle"></i>
                    <span id="prevExerciseName">Anterior</span>
                </a>
                
                <!-- CENTRO: Men√∫ desplegable de ejercicios -->
                <div class="nav-spacer">
                    <div class="exercise-dropdown-container">
                        <button class="exercise-dropdown-btn" id="exerciseMenuBtn">
                            <i class="bi bi-list-ul"></i>
                            <span id="currentExerciseIndicator">Men√∫ de Ejercicios</span>
                            <i class="bi bi-chevron-down"></i>
                        </button>
                        <div class="exercise-dropdown-menu" id="exerciseDropdownMenu" style="display: none;">
                            <div class="dropdown-header">
                                <span>Todos los Ejercicios</span>
                            </div>
                            <div class="dropdown-items" id="exerciseDropdownItems">
                                <!-- Se llenar√° din√°micamente con JavaScript -->
                            </div>
                            <div class="dropdown-footer">
                                <a href="{{ url_for('exercise_selector', joint_type=joint_type) }}" class="dropdown-back-link">
                                    <i class="bi bi-arrow-left"></i> Volver al selector
                                </a>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- DERECHA: Siguiente -->
                <a href="#" id="nextExerciseBtn" class="nav-exercise-link nav-right" style="visibility: hidden;">
                    <span id="nextExerciseName">Siguiente</span>
                    <i class="bi bi-arrow-right-circle"></i>
                </a>
            </div>
        </div>
    </div>
</div>

<!-- üîΩ BOT√ìN DE SCROLL FLOTANTE -->
<button id="scrollDownBtn" class="scroll-down-indicator" style="display: none;">
    <i class="bi bi-chevron-double-down"></i>
</button>

<!-- üìä SECCI√ìN HISTORIAL DE AN√ÅLISIS COMPACTO -->
<div class="container mt-4" style="position: relative; z-index: 1;">
    <div class="row">
        <div class="col-md-8">
            <div class="biomech-glass" style="border-radius: 16px; overflow: hidden; position: relative; z-index: 1;">
                <div class="card-header" style="background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(107, 70, 193, 0.1)); 
                                                border-bottom: 1px solid rgba(0, 212, 255, 0.2); 
                                                padding: 1rem 1.5rem;">
                    <h5 class="mb-0" style="color: var(--biomech-cyan); 
                                            font-weight: 600; 
                                            text-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
                                            display: flex;
                                            align-items: center;
                                            gap: 0.5rem;">
                        <i class="bi bi-clock-history"></i> Historial de An√°lisis
                    </h5>
                </div>
                <div class="card-body p-0">
                    <!-- üìú SCROLL CONTAINER para historial -->
                    <div id="analysisHistory" style="max-height: 300px; overflow-y: auto; padding: 0.5rem;">
                        <p class="text-muted p-3">Cargando historial...</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="col-md-4">
            <div class="biomech-glass" style="border-radius: 16px; overflow: hidden;">
                <div class="card-header" style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(0, 212, 255, 0.1)); 
                                                border-bottom: 1px solid rgba(16, 185, 129, 0.2); 
                                                padding: 1rem 1.5rem;">
                    <h5 class="mb-0" style="color: var(--biomech-green); 
                                            font-weight: 600; 
                                            text-shadow: 0 0 10px rgba(16, 185, 129, 0.3);
                                            display: flex;
                                            align-items: center;
                                            gap: 0.5rem;">
                        <i class="bi bi-trophy"></i> Estad√≠sticas
                    </h5>
                </div>
                <div class="card-body" style="padding: 1.5rem;">
                    <div id="romStats">
                        <p class="text-muted">Realizar an√°lisis para ver estad√≠sticas...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
/* ÔøΩ ESTILOS MODAL FULLSCREEN AN√ÅLISIS */
.analysis-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    z-index: 9999;
    align-items: center;
    justify-content: center;
    animation: fadeIn 0.3s ease;
}

.analysis-modal.active {
    display: flex;
}

.analysis-modal-content {
    position: relative;
    width: 90%;
    max-width: 1200px;
    height: 90vh;
    animation: scaleIn 0.3s ease;
}

.analysis-close-btn {
    position: absolute;
    top: -50px;
    right: 0;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.3);
    color: white;
    font-size: 24px;
    width: 45px;
    height: 45px;
    border-radius: 50%;
    cursor: pointer;
    z-index: 10000;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.analysis-close-btn:hover {
    background: rgba(255, 59, 48, 0.8);
    border-color: rgba(255, 59, 48, 1);
    transform: scale(1.1);
}

/* ‚öôÔ∏è BOTON FLOTANTE CONFIGURACION CAMARA */
.floating-camera-settings-btn {
    position: fixed;
    bottom: 30px;
    left: 30px;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--biomech-cyan) 0%, var(--biomech-blue) 100%);
    border: 2px solid rgba(255, 255, 255, 0.2);
    color: white;
    font-size: 24px;
    cursor: pointer;
    z-index: 9998;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
}

.floating-camera-settings-btn:hover {
    transform: scale(1.1) rotate(90deg);
    box-shadow: 0 6px 25px rgba(0, 255, 255, 0.5);
    background: linear-gradient(135deg, var(--biomech-blue) 0%, var(--biomech-purple) 100%);
}

.floating-camera-settings-btn:active {
    transform: scale(0.95) rotate(90deg);
}

@media (max-width: 768px) {
    .floating-camera-settings-btn {
        width: 50px;
        height: 50px;
        bottom: 20px;
        left: 20px;
        font-size: 20px;
    }
}

/* üîä BOTON FLOTANTE AUDIO TOGGLE */
.floating-audio-toggle-btn {
    position: fixed;
    bottom: 30px;
    right: 30px; /* Alineado con el lado derecho, espejo del gear icon */
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
    border: 2px solid rgba(255, 255, 255, 0.2);
    color: white;
    font-size: 24px;
    cursor: pointer;
    z-index: 10000; /* ‚úÖ Por encima del modal de an√°lisis (9999) y preview */
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
}

.floating-audio-toggle-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 25px rgba(76, 175, 80, 0.5);
    background: linear-gradient(135deg, #45a049 0%, #4CAF50 100%);
}

.floating-audio-toggle-btn:active {
    transform: scale(0.95);
}

.floating-audio-toggle-btn.muted {
    background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
    box-shadow: 0 4px 15px rgba(244, 67, 54, 0.3);
}

.floating-audio-toggle-btn.muted:hover {
    box-shadow: 0 6px 25px rgba(244, 67, 54, 0.5);
}

@media (max-width: 768px) {
    .floating-audio-toggle-btn {
        width: 50px;
        height: 50px;
        bottom: 20px;
        right: 20px; /* Alineado a la derecha en mobile */
        font-size: 20px;
    }
}

/* üîç BOTON FLOTANTE DEBUG TOGGLE (SOLO ADMIN) */
.floating-debug-toggle-btn {
    position: fixed;
    bottom: 110px; /* Encima del bot√≥n de audio */
    right: 30px;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
    border: 2px solid rgba(255, 255, 255, 0.2);
    color: white;
    font-size: 24px;
    cursor: pointer;
    z-index: 100000;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
}

.floating-debug-toggle-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 25px rgba(255, 107, 107, 0.5);
    background: linear-gradient(135deg, #ee5a6f 0%, #c44569 100%);
}

.floating-debug-toggle-btn:active {
    transform: scale(0.95);
}

@media (max-width: 768px) {
    .floating-debug-toggle-btn {
        width: 50px;
        height: 50px;
        bottom: 90px;
        right: 20px;
        font-size: 20px;
    }
}

/* üîç DEBUG PANEL (SOLO ADMIN) */
.debug-panel {
    position: fixed;
    top: 80px;
    right: 20px;
    width: 350px;
    max-height: calc(100vh - 100px);
    background: rgba(20, 20, 30, 0.98);
    border: 2px solid rgba(255, 107, 107, 0.5);
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(255, 107, 107, 0.3);
    z-index: 100000;
    overflow: hidden;
    animation: slideInRight 0.3s ease;
}

@keyframes slideInRight {
    from {
        transform: translateX(400px);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.debug-panel-header {
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
    padding: 15px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 2px solid rgba(255, 255, 255, 0.1);
}

.debug-panel-header h5 {
    margin: 0;
    color: white;
    font-size: 16px;
    font-weight: 600;
}

.debug-panel-body {
    padding: 20px;
    max-height: calc(100vh - 180px);
    overflow-y: auto;
    color: #fff;
}

.debug-panel-body::-webkit-scrollbar {
    width: 6px;
}

.debug-panel-body::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
}

.debug-panel-body::-webkit-scrollbar-thumb {
    background: rgba(255, 107, 107, 0.5);
    border-radius: 3px;
}

.debug-status {
    background: rgba(255, 255, 255, 0.05);
    padding: 12px;
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.debug-status i.bi-circle-fill {
    font-size: 10px;
    margin-right: 5px;
}

.debug-info {
    background: rgba(255, 255, 255, 0.05);
    padding: 10px;
    border-radius: 6px;
    font-size: 13px;
}

.debug-result {
    background: rgba(76, 175, 80, 0.1);
    border: 1px solid rgba(76, 175, 80, 0.3);
    padding: 12px;
    border-radius: 8px;
    font-size: 13px;
}

.alert-sm {
    padding: 8px 12px;
    font-size: 13px;
    margin-bottom: 0;
}

@media (max-width: 768px) {
    .debug-panel {
        width: calc(100vw - 40px);
        right: 20px;
        left: 20px;
    }
}

.modal-stream-wrapper {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    background-color: #000000;
}

.modal-stream-wrapper .stream-container {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #000000;
}

.modal-stream-wrapper img {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    border-radius: 12px;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes scaleIn {
    from {
        transform: scale(0.95);
        opacity: 0;
    }
    to {
        transform: scale(1);
        opacity: 1;
    }
}

@keyframes fadeOut {
    from { opacity: 1; }
    to { opacity: 0; }
}

.analysis-modal.closing {
    animation: fadeOut 0.3s ease;
}

/* ÔøΩüé® ESTILOS BIOMEC√ÅNICOS PARA HISTORIAL Y ESTAD√çSTICAS */

/* Scrollbar personalizado para historial */
#analysisHistory::-webkit-scrollbar {
    width: 8px;
}

#analysisHistory::-webkit-scrollbar-track {
    background: rgba(15, 23, 42, 0.5);
    border-radius: 10px;
}

#analysisHistory::-webkit-scrollbar-thumb {
    background: linear-gradient(180deg, var(--biomech-cyan), var(--biomech-purple));
    border-radius: 10px;
    transition: all 0.3s ease;
}

#analysisHistory::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(180deg, var(--biomech-purple), var(--biomech-cyan));
    box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
}

/* Animaci√≥n de fade-in para items del historial */
@keyframes fadeInSlide {
    from {
        opacity: 0;
        transform: translateX(-20px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

#analysisHistory > div {
    animation: fadeInSlide 0.4s ease-out;
}

/* Animaci√≥n pulsante para estad√≠sticas nuevas */
@keyframes pulse {
    0%, 100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.05);
    }
}

/* Efecto glow en hover para tarjetas de stats */
#romStats > div > div:hover {
    animation: pulse 1s ease-in-out;
}

/* üÜï ESTILOS PARA NAVEGACI√ìN DE EJERCICIOS (layout mejorado) */
/* Contenedor global: siempre visible, fuera de initialMessage */
/* Navegaci√≥n de ejercicios - Posicionada abajo, estilo biomech-glass */
.global-exercise-navigation {
    width: 100%;
    max-width: 1200px;
    margin: 0 auto;
    position: relative;
    z-index: 100; /* ‚úÖ Mayor que historial (z-index: 1) */
}

.exercise-nav-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 2rem;
}

.nav-spacer {
    flex: 1;
    min-width: 100px;
    display: flex;
    justify-content: center; /* ‚úÖ Centra el men√∫ horizontalmente */
    align-items: center;
}

.current-exercise-title {
    flex: 0 0 auto;
    text-align: center;
}

.main-action-center {
    flex: 0 0 auto;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
}

.nav-exercise-link {
    flex: 1;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    color: var(--biomech-cyan);
    text-decoration: none;
    font-size: 1rem;
    font-weight: 500;
    transition: all 0.3s ease;
    padding: 0.75rem 1.25rem;
    border-radius: 10px;
    min-width: 180px;
    background: rgba(0, 212, 255, 0.08);
    border: 1.5px solid rgba(0, 212, 255, 0.3);
    backdrop-filter: blur(5px);
}

/* Alineaci√≥n seg√∫n posici√≥n */
.nav-exercise-link.nav-left {
    justify-content: flex-start;
}

.nav-exercise-link.nav-right {
    justify-content: flex-end;
}

.nav-exercise-link:hover:not(.disabled) {
    color: #ffffff;
    background: rgba(0, 212, 255, 0.2);
    border-color: var(--biomech-cyan);
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(0, 212, 255, 0.25);
}

.nav-exercise-link i {
    font-size: 1.5rem;
    transition: transform 0.3s ease;
}

.nav-exercise-link:hover:not(.disabled) i {
    transform: scale(1.15);
}

/* Estado deshabilitado (durante an√°lisis) */
.nav-exercise-link.disabled {
    color: rgba(255, 255, 255, 0.25);
    cursor: not-allowed;
    background: rgba(255, 255, 255, 0.02);
}

/* =============================================================================
   üéØ MEN√ö DESPLEGABLE DE EJERCICIOS
   ============================================================================= */

.exercise-dropdown-container {
    position: relative;
    display: inline-block;
    z-index: 200; /* ‚úÖ Garantizar que est√© sobre todo */
}

.exercise-dropdown-btn {
    background: rgba(0, 212, 255, 0.12);
    border: 1.5px solid rgba(0, 212, 255, 0.3);
    border-radius: 12px;
    padding: 0.75rem 1.5rem;
    color: var(--biomech-cyan);
    font-weight: 500;
    font-size: 0.95rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    transition: all 0.3s ease;
    white-space: nowrap;
}

.exercise-dropdown-btn:hover {
    background: rgba(0, 212, 255, 0.2);
    border-color: var(--biomech-cyan);
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 212, 255, 0.25);
}

.exercise-dropdown-menu {
    position: absolute;
    top: calc(100% + 10px);
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.95);
    backdrop-filter: blur(12px);
    border: 1px solid rgba(0, 212, 255, 0.3);
    border-radius: 12px;
    min-width: 320px;
    max-width: 420px;
    max-height: 500px;
    overflow: hidden;
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
    z-index: 99999; /* ‚úÖ M√°xima prioridad - sobre todo incluyendo historial */
    animation: dropdownFadeIn 0.2s ease;
}

@keyframes dropdownFadeIn {
    from {
        opacity: 0;
        transform: translateX(-50%) translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
}

.dropdown-header {
    padding: 1rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    font-weight: 600;
    color: var(--biomech-cyan);
    text-align: center;
}

.dropdown-segment-header {
    padding: 0.6rem 1rem;
    margin-top: 0.5rem;
    font-weight: 600;
    font-size: 0.85rem;
    color: var(--biomech-cyan);
    background: rgba(0, 212, 255, 0.1);
    border-left: 3px solid var(--biomech-cyan);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.dropdown-segment-header:first-child {
    margin-top: 0;
}

.dropdown-items {
    max-height: 380px; /* ‚úÖ Aumentado para mostrar m√°s ejercicios */
    overflow-y: auto; /* ‚úÖ Scroll vertical autom√°tico */
    overflow-x: hidden;
    padding: 0.5rem;
    /* Estilos personalizados para scrollbar */
    scrollbar-width: thin;
    scrollbar-color: rgba(0, 212, 255, 0.5) rgba(255, 255, 255, 0.1);
}

/* Scrollbar para navegadores Webkit (Chrome, Safari, Edge) */
.dropdown-items::-webkit-scrollbar {
    width: 8px;
}

.dropdown-items::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 4px;
}

.dropdown-items::-webkit-scrollbar-thumb {
    background: rgba(0, 212, 255, 0.5);
    border-radius: 4px;
    transition: background 0.3s ease;
}

.dropdown-items::-webkit-scrollbar-thumb:hover {
    background: rgba(0, 212, 255, 0.8);
}

.dropdown-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem 1rem;
    color: rgba(255, 255, 255, 0.8);
    text-decoration: none;
    border-radius: 8px;
    transition: all 0.2s ease;
    margin-bottom: 0.25rem;
}

.dropdown-item:hover {
    background: rgba(0, 212, 255, 0.15);
    color: white;
    transform: translateX(5px);
}

.dropdown-item.active {
    background: rgba(0, 212, 255, 0.25);
    color: var(--biomech-cyan);
    font-weight: 600;
    border-left: 3px solid var(--biomech-cyan);
}

.dropdown-item i {
    font-size: 1.2rem;
    color: var(--biomech-cyan);
}

.dropdown-footer {
    padding: 0.75rem 1rem;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    background: rgba(0, 0, 0, 0.3);
}

.dropdown-back-link {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: rgba(255, 255, 255, 0.6);
    text-decoration: none;
    font-size: 0.9rem;
    transition: all 0.2s ease;
}

.dropdown-back-link:hover {
    color: var(--biomech-cyan);
    transform: translateX(-3px);
}

/* Scrollbar del dropdown */
.dropdown-items::-webkit-scrollbar {
    width: 6px;
}

.dropdown-items::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 3px;
}

.dropdown-items::-webkit-scrollbar-thumb {
    background: rgba(0, 212, 255, 0.3);
    border-radius: 3px;
}

.dropdown-items::-webkit-scrollbar-thumb:hover {
    background: rgba(0, 212, 255, 0.5);
}

/* =============================================================================
   üîΩ BOT√ìN DE SCROLL FLOTANTE
   ============================================================================= */

.scroll-down-indicator {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 212, 255, 0.9);
    backdrop-filter: blur(10px);
    border: 2px solid rgba(0, 212, 255, 0.5);
    border-radius: 50%;
    width: 56px;
    height: 56px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 9000;
    box-shadow: 0 6px 24px rgba(0, 212, 255, 0.5);
    animation: scrollBounce 2s ease-in-out infinite;
    transition: all 0.3s ease;
    color: white;
    font-size: 1.5rem;
}

.scroll-down-indicator:hover {
    background: rgba(0, 212, 255, 1);
    transform: translateX(-50%) scale(1.1);
    box-shadow: 0 8px 32px rgba(0, 212, 255, 0.7);
    animation: none;
}

@keyframes scrollBounce {
    0%, 100% {
        transform: translateX(-50%) translateY(0);
    }
    50% {
        transform: translateX(-50%) translateY(10px);
    }
}

/* =============================================================================
   üé® ESTILO UNIFICADO PARA BOTONES FLOTANTES (Audio, C√°mara, etc.)
   ============================================================================= */

.floating-control-btn {
    position: fixed;
    right: 20px;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    width: 50px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    z-index: 10000;
    color: var(--biomech-cyan);
    font-size: 1.3rem;
}

.floating-control-btn:hover {
    background: rgba(0, 212, 255, 0.2);
    border-color: var(--biomech-cyan);
    transform: scale(1.05);
    box-shadow: 0 10px 36px rgba(0, 212, 255, 0.4);
}

/* Posicionamiento de botones flotantes */
#audio-toggle-btn {
    top: 80px;
}

#camera-settings-btn {
    top: 145px;
}

/* Estado deshabilitado (durante an√°lisis) */
.nav-exercise-link.disabled {
    color: rgba(255, 255, 255, 0.25);
    background: rgba(255, 255, 255, 0.02);
    border-color: rgba(255, 255, 255, 0.1);
    cursor: not-allowed;
    pointer-events: none;
    opacity: 0.5;
}

/* Responsive: en pantallas peque√±as, apilar verticalmente */
@media (max-width: 768px) {
    .exercise-nav-container {
        flex-direction: column;
        gap: 1rem;
    }
    
    .nav-exercise-link {
        min-width: 100%;
        justify-content: center !important;
    }
    
    .current-exercise-title h4 {
        font-size: 1rem;
    }
}
</style>

{% endblock %}

{% block scripts %}
<!-- ‚úÖ MANTENER: Detector de c√°mara -->
<script src="{{ url_for('static', filename='js/quick_camera_detector.js') }}"></script>
<script src="{{ url_for('static', filename='js/client_camera_handler.js') }}"></script>

<!-- üÜï ROM SESSION MANAGER -->
<script src="{{ url_for('static', filename='js/rom_session_manager.js') }}"></script>

<!-- ‚öôÔ∏è CAMERA SETTINGS SYSTEM -->
<!-- camera_settings.js se carga desde base.html para evitar cargas duplicadas -->

<!-- ‚öïÔ∏è STREAM HEALTH MONITOR (SESSION 3 - Detecta c√°mara fallida) -->
<script src="{{ url_for('static', filename='js/stream_health_monitor.js') }}?v={{ range(1, 99999) | random }}"></script>

<!-- üß≠ ORIENTATION VALIDATOR (NUEVO - Validaci√≥n de orientaci√≥n) -->
<script src="{{ url_for('static', filename='js/orientation_validator.js') }}"></script>

<!-- üîä AUDIO GUIDE SYSTEM - Already loaded in base.html, no need to load again -->
<!-- <script src="{{ url_for('static', filename='js/audio_guide_system.js') }}"></script> -->

<!-- üì∑ CAMERA PRE-LOAD SYSTEM (runs automatically on page load) -->
<!-- ‚úÖ Script already included above - preloadCamerasOnPageLoad() runs via DOMContentLoaded -->

<script>
// =============================================================================
// üéØ CONFIGURACI√ìN ESCALABLE
// =============================================================================

// üö® LOGS CR√çTICOS AL INICIO - v2.0 ANTI-CACHE

// ‚úÖ DECLARAR EXERCISE_CONFIG GLOBALMENTE (fuera de try/catch)
const EXERCISE_CONFIG = {
    segment: '{{ exercise_config.segment if exercise_config else "shoulder" }}',
    exercise: '{{ exercise_config.exercise if exercise_config else "flexion" }}',
    name: '{{ exercise_config.exercise_name if exercise_config else "An√°lisis de Hombro" }}',
    plane: '{{ exercise_config.plane if exercise_config else "sagital" }}',
    type: '{{ joint_type if joint_type else "shoulder" }}',
    camera_orientation: '{{ exercise_config.camera_orientation if exercise_config and exercise_config.camera_orientation else "sagital" }}',  // üÜï AGREGADO
    duration_seconds: {{ exercise_config.duration_seconds if exercise_config and exercise_config.duration_seconds else 14 }},
    rom_capture_config: {{ exercise_config.rom_capture_config|tojson if exercise_config and exercise_config.rom_capture_config else '{"active_capture_duration": 14}'|tojson }},
    tts_phases: {{ exercise_config.tts_phases|tojson if exercise_config and exercise_config.tts_phases else '{}'|tojson }}
}

try {
    // üîä INICIALIZAR AUDIO INTEGRATOR
    window.EXERCISE_CONFIG = EXERCISE_CONFIG; // Exponer globalmente para el integrador
} catch (error) {
    console.error('‚ùå ERROR CR√çTICO con EXERCISE_CONFIG:', error);
}

// =============================================================================
// üéÆ VARIABLES GLOBALES
// =============================================================================

// ‚úÖ DECLARAR VARIABLES GLOBALMENTE (sin try/catch que las oculte)
// üéõÔ∏è SISTEMA DE CONTROL DE ESTADO CENTRALIZADO
let analysisState = 'stopped'
let isResetInProgress = false  // üõ°Ô∏è Flag espec√≠fico para reset
let activeProcessIds = new Set()  // üîç Tracking de procesos activos
let activeIntervals = new Set()  // üîÑ Tracking de intervalos activos

// üéØ VARIABLE GLOBAL: Almacenar info de c√°mara detectada
let selectedCameraInfo = null

// üÜï VARIABLE GLOBAL: ROM Session Manager
let romSession = null  // ‚úÖ Necesaria para sistema ROM integrado

// üõ°Ô∏è FUNCIONES DE CONTROL DE ESTADO
function setAnalysisState(newState, processId = null) {
    console.log(`üîÑ Estado: ${analysisState} ‚Üí ${newState} ${processId ? `(${processId})` : ''}`)
    
    // Validar transiciones de estado v√°lidas
    const validTransitions = {
        'stopped': ['loading', 'resetting'],
        'loading': ['running', 'stopped', 'resetting'],
        'running': ['paused', 'stopped', 'resetting'],
        'paused': ['running', 'stopped', 'resetting'],
        'resetting': ['stopped']
    }
    
    if (!validTransitions[analysisState]?.includes(newState)) {
        console.warn(`‚ö†Ô∏è Transici√≥n inv√°lida: ${analysisState} ‚Üí ${newState}`)
        return false
    }
    
    analysisState = newState
    
    if (processId) {
        if (newState === 'stopped' || newState === 'resetting') {
            activeProcessIds.delete(processId)
        } else {
            activeProcessIds.add(processId)
        }
    }
    
    return true
}

function isSystemBusy() {
    // üõ°Ô∏è L√ìGICA INTELIGENTE: Solo bloquear si realmente hay actividad peligrosa
    const isBusy = isResetInProgress || analysisState === 'resetting'
    
    return isBusy
}

// =============================================================================
// üÜï SISTEMA DE NAVEGACI√ìN DE EJERCICIOS
// =============================================================================

// üìã ORDEN LINEAL GLOBAL de ejercicios (14 ejercicios - sin cuello)
// üîß NOTA: Si agregas ejercicios, actualiza este array manualmente
const EXERCISE_ORDER = [
    {joint: 'shoulder', exercise: 'flexion', name: 'Flexi√≥n de Hombro'},
    {joint: 'shoulder', exercise: 'extension', name: 'Extensi√≥n de Hombro'},
    {joint: 'shoulder', exercise: 'abduction', name: 'Abducci√≥n de Hombro'},
    {joint: 'elbow', exercise: 'flexion', name: 'Flexi√≥n de Codo'},
    {joint: 'elbow', exercise: 'extension', name: 'Extensi√≥n de Codo'},
    {joint: 'elbow', exercise: 'overhead_extension', name: 'Extensi√≥n Over Head de Codo'},
    {joint: 'hip', exercise: 'flexion', name: 'Flexi√≥n de Cadera'},
    {joint: 'hip', exercise: 'abduction', name: 'Abducci√≥n de Cadera'},
    {joint: 'hip', exercise: 'adduction', name: 'Aducci√≥n de Cadera'},
    {joint: 'knee', exercise: 'flexion', name: 'Flexi√≥n de Rodilla'},
    {joint: 'knee', exercise: 'extension', name: 'Extensi√≥n de Rodilla'},
    {joint: 'ankle', exercise: 'flexion', name: 'Flexi√≥n de Tobillo'},
    {joint: 'ankle', exercise: 'dorsiflexion', name: 'Dorsiflexi√≥n de Tobillo'},
    {joint: 'ankle', exercise: 'inversion', name: 'Inversi√≥n de Tobillo'}
];

// üéØ Obtener √≠ndice del ejercicio actual
function getCurrentExerciseIndex() {
    const currentJoint = EXERCISE_CONFIG.segment;
    const currentExercise = EXERCISE_CONFIG.exercise;
    
    return EXERCISE_ORDER.findIndex(ex => 
        ex.joint === currentJoint && ex.exercise === currentExercise
    );
}

// üìä Obtener informaci√≥n de navegaci√≥n
function getNavigationInfo() {
    const currentIdx = getCurrentExerciseIndex();
    
    if (currentIdx === -1) {
        console.warn('‚ö†Ô∏è Ejercicio actual no encontrado en EXERCISE_ORDER');
        return {hasPrevious: false, hasNext: false};
    }
    
    return {
        currentIndex: currentIdx,
        hasPrevious: currentIdx > 0,
        hasNext: currentIdx < EXERCISE_ORDER.length - 1,
        previous: currentIdx > 0 ? EXERCISE_ORDER[currentIdx - 1] : null,
        next: currentIdx < EXERCISE_ORDER.length - 1 ? EXERCISE_ORDER[currentIdx + 1] : null
    };
}

// üîÑ Actualizar UI de navegaci√≥n
function updateNavigationUI() {
    const navInfo = getNavigationInfo();
    
    const prevBtn = document.getElementById('prevExerciseBtn');
    const nextBtn = document.getElementById('nextExerciseBtn');
    const prevName = document.getElementById('prevExerciseName');
    const nextName = document.getElementById('nextExerciseName');
    
    // üéØ Mostrar/ocultar botones seg√∫n disponibilidad (con visibility)
    if (navInfo.hasPrevious && navInfo.previous) {
        prevBtn.style.visibility = 'visible';
        prevName.textContent = navInfo.previous.name;
        prevBtn.href = `/analysis/${navInfo.previous.joint}/${navInfo.previous.exercise}`;
    } else {
        prevBtn.style.visibility = 'hidden';  // ‚úÖ Hidden mantiene el espacio
    }
    
    if (navInfo.hasNext && navInfo.next) {
        nextBtn.style.visibility = 'visible';
        nextName.textContent = navInfo.next.name;
        nextBtn.href = `/analysis/${navInfo.next.joint}/${navInfo.next.exercise}`;
    } else {
        nextBtn.style.visibility = 'hidden';  // ‚úÖ Hidden mantiene el espacio
    }
    
    console.log('üß≠ Navegaci√≥n actualizada:', navInfo);
}

// üõ°Ô∏è Deshabilitar navegaci√≥n durante an√°lisis (sin ocultar)
function disableNavigationDuringAnalysis() {
    const prevBtn = document.getElementById('prevExerciseBtn');
    const nextBtn = document.getElementById('nextExerciseBtn');
    
    // ‚úÖ Solo agregar clase 'disabled' (se ven opacos pero NO desaparecen)
    if (prevBtn.style.visibility === 'visible') {
        prevBtn.classList.add('disabled');
    }
    if (nextBtn.style.visibility === 'visible') {
        nextBtn.classList.add('disabled');
    }
}

// ‚úÖ Habilitar navegaci√≥n despu√©s de an√°lisis
function enableNavigationAfterAnalysis() {
    const prevBtn = document.getElementById('prevExerciseBtn');
    const nextBtn = document.getElementById('nextExerciseBtn');
    
    // ‚úÖ Remover clase 'disabled' (vuelven a estado normal)
    prevBtn.classList.remove('disabled');
    nextBtn.classList.remove('disabled');
}

// üîÑ FUNCIONES DE GESTI√ìN DE INTERVALOS
function addInterval(intervalId) {
    activeIntervals.add(intervalId)
    return intervalId
}

function clearAllIntervals() {
    activeIntervals.forEach(intervalId => {
        clearInterval(intervalId)
        clearTimeout(intervalId)
    })
    activeIntervals.clear()
}
let isLoadingHistory = false  // üõ°Ô∏è Flag para prevenir m√∫ltiples llamadas de historial
let currentStreamImg = null

try {
    // Variables globales inicializadas
} catch (error) {
    console.error('‚ùå ERROR en variables globales:', error);
}

// =============================================================================
// üìä FUNCIONES DE INTERFAZ
// =============================================================================

function updateStatus(message, status) {
    const statusElement = document.getElementById('analysisStatus');
    if (statusElement) {
        statusElement.textContent = message;
        statusElement.className = 'status-badge';
        
        switch(status) {
            case 'loading':
                statusElement.style.color = '#ffc107'
                statusElement.style.backgroundColor = 'rgba(255, 193, 7, 0.1)'
                break
            case 'active':
                statusElement.style.color = '#28a745'
                statusElement.style.backgroundColor = 'rgba(40, 167, 69, 0.1)'
                break
            case 'error':
                statusElement.style.color = '#dc3545'
                statusElement.style.backgroundColor = 'rgba(220, 53, 69, 0.1)'
                break
            default:
                statusElement.style.color = '#ffffff'
                statusElement.style.backgroundColor = 'rgba(255, 255, 255, 0.1)'
        }
    }
    console.log(`üìä Status: ${message} (${status})`)
}

function updateStreamStatus(message) {
    const streamStatusElement = document.getElementById('streamStatus');
    if (streamStatusElement) {
        streamStatusElement.textContent = message;
        
        if (message.includes('conectado')) {
            streamStatusElement.style.color = '#28a745';
        } else if (message.includes('error')) {
            streamStatusElement.style.color = '#dc3545';
        } else {
            streamStatusElement.style.color = '#6c757d';
        }
    }
}

function resetInterface() {
    console.log('üîÑ Reseteando interfaz...')
    
    // üéØ PRESERVAR selectedCameraInfo entre resets
    console.log('üíæ Preservando selectedCameraInfo:', selectedCameraInfo);
    
    // üé¨ DEVOLVER STREAM A SU POSICI√ìN ORIGINAL
    const streamContainer = document.querySelector('.stream-container')
    const originalParent = document.querySelector('#analysisInterface .col-lg-8 .analysis-panel')
    if (streamContainer && originalParent) {
        // Insertar despu√©s del panel-header
        const panelHeader = originalParent.querySelector('.panel-header')
        if (panelHeader) {
            panelHeader.insertAdjacentElement('afterend', streamContainer)
        }
    }
    
    // üé¨ CERRAR MODAL
    const modal = document.getElementById('analysisModal')
    if (modal) {
        modal.classList.remove('active')
    }
    
    document.getElementById('startAnalysisBtn').style.display = 'inline-block'
    document.getElementById('runningButtons').style.display = 'none'
    document.getElementById('analysisInterface').style.display = 'none'
    document.getElementById('initialMessage').style.display = 'block'
    
    const streamImg = document.getElementById('analysisStream')
    if (streamImg) {
        streamImg.src = ''
        streamImg.style.display = 'none'
    }
    
    const loadingMsg = document.getElementById('loadingMessage')
    if (loadingMsg) {
        loadingMsg.style.display = 'block'
    }
    
    analysisState = 'stopped'
    updateStatus('Sistema listo', 'ready')
    updateStreamStatus('Inactivo')
    
    // üîì HABILITAR NAVEGACI√ìN al resetear interfaz
    enableNavigationAfterAnalysis()
}

// =============================================================================
// üéØ FUNCIONES DE AN√ÅLISIS
// =============================================================================

/**
 * üß≠ VALIDACI√ìN GLOBAL DE ORIENTACI√ìN
 * Espera hasta que el usuario est√© en la orientaci√≥n correcta (FRONTAL o PERFIL)
 * Compatible con todos los segmentos y ejercicios
 * 
 * @param {string} requiredOrientation - Orientaci√≥n requerida: "frontal" o "sagital"
 * @param {number} maxWaitTime - Tiempo m√°ximo de espera en milisegundos (default: 30000)
 * @returns {Promise<boolean>} - true si orientaci√≥n correcta, false si timeout
 */
async function waitForCorrectOrientation(requiredOrientation, maxWaitTime = 30000) {
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('üß≠ [waitForCorrectOrientation] INICIANDO VALIDACI√ìN DE ORIENTACI√ìN');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log(`üìã Par√°metros de entrada:`);
    console.log(`   - requiredOrientation RAW: "${requiredOrientation}" (tipo: ${typeof requiredOrientation})`);
    console.log(`   - maxWaitTime: ${maxWaitTime}ms (${maxWaitTime/1000}s)`);
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    
    const startTime = Date.now()
    let lastFeedbackTime = 0
    const FEEDBACK_INTERVAL = 2000  // Feedback cada 2 segundos
    let attemptCount = 0
    
    // üÜï CONTADORES PARA DETECCI√ìN DE "NO HAY USUARIO"
    let noUserCount = 0
    const MAX_NO_USER_ATTEMPTS = 10  // 5 segundos (10 * 500ms)
    const NO_USER_CONFIDENCE_THRESHOLD = 0.3  // Confianza < 0.3 = no hay usuario
    
    // üÜï STABILITY CHECK - Requiere 2 segundos en orientaci√≥n correcta (ya pas√≥ 5s en detecci√≥n)
    let stableOrientationStart = null
    const STABILITY_DURATION = 2000  // 2 segundos de estabilidad
    
    // üîß NORMALIZAR orientaci√≥n requerida (CR√çTICO)
    const requiredNormalized = String(requiredOrientation || 'sagital').trim().toUpperCase()
    console.log(`üîß NORMALIZACI√ìN:`);
    console.log(`   Original: "${requiredOrientation}"`);
    console.log(`   Normalizada: "${requiredNormalized}"`);
    console.log(`   Bytes: [${Array.from(requiredNormalized).map(c => c.charCodeAt(0)).join(', ')}]`);
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    
    // üéØ UMBRAL DE CONFIANZA
    const MIN_CONFIDENCE = 0.6
    console.log(`üéØ Umbral de confianza m√≠nima: ${MIN_CONFIDENCE}`);
    console.log(`üö´ Umbral "no hay usuario": < ${NO_USER_CONFIDENCE_THRESHOLD}`);
    console.log(`‚è±Ô∏è Timeout sin usuario: ${MAX_NO_USER_ATTEMPTS * 500 / 1000}s`);
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    
    return new Promise((resolve, reject) => {
        const checkInterval = setInterval(async () => {
            attemptCount++
            const elapsed = Date.now() - startTime
            
            // ‚è±Ô∏è Verificar timeout SOLO si hay usuario presente
            if (elapsed > maxWaitTime && noUserCount < MAX_NO_USER_ATTEMPTS) {
                clearInterval(checkInterval)
                activeIntervals.delete(checkInterval)
                console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                console.warn(`‚è∞ [TIMEOUT CON USUARIO] No se logr√≥ orientaci√≥n correcta en ${maxWaitTime/1000}s`)
                console.warn(`   El usuario est√° presente pero no en la posici√≥n correcta`)
                console.warn(`   Intentos realizados: ${attemptCount}`)
                console.warn(`   √öltima orientaci√≥n detectada: ${window.lastDetectedOrientation || 'ninguna'}`)
                console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                updateStatus('‚è∞ Tiempo agotado. No se logr√≥ la orientaci√≥n correcta', 'error')
                
                // üõë CANCELAR an√°lisis (usuario no coopera)
                await cancelAnalysis('Timeout de orientaci√≥n')
                resolve(null)  // null = cancelado
                return
            }
            
            try {
                // üì° Obtener status del handler actual
                const url = `/api/rom/status/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`
                
                // Log solo cada 10 intentos para no spammear
                if (attemptCount % 10 === 1) {
                    console.log(`üîç [Intento ${attemptCount}] GET ${url}`)
                }
                
                const statusResponse = await fetch(url)
                
                if (!statusResponse.ok) {
                    if (attemptCount % 10 === 1) {
                        console.warn(`‚ö†Ô∏è Response no OK: ${statusResponse.status}`)
                    }
                    return  // Continuar esperando
                }
                
                const status = await statusResponse.json()
                
                // Log de estructura completa SOLO en primer intento
                if (attemptCount === 1) {
                    console.log(`üì¶ Estructura del response:`, JSON.stringify(status, null, 2))
                }
                
                // ‚úÖ Verificar estructura de datos
                const detectionInfo = status.status?.detection
                
                if (!detectionInfo) {
                    if (attemptCount % 10 === 1) {
                        console.warn(`‚ö†Ô∏è No hay detection info en status`)
                        console.warn(`   Keys disponibles:`, Object.keys(status))
                        console.warn(`   status keys:`, status.status ? Object.keys(status.status) : 'N/A')
                    }
                    return
                }
                
                if (!detectionInfo.orientation) {
                    if (attemptCount % 10 === 1) {
                        console.warn(`‚ö†Ô∏è No hay orientation en detection_info`)
                        console.warn(`   detection_info keys:`, Object.keys(detectionInfo))
                    }
                    return
                }
                
                // üîç EXTRAER Y NORMALIZAR orientaci√≥n detectada
                const currentOrientation = String(detectionInfo.orientation || '').trim().toUpperCase()
                const confidence = parseFloat(detectionInfo.orientation_confidence || 0)
                const poseDetected = Boolean(detectionInfo.pose_detected)
                const activeSide = status.status?.active_side || null  // üÜï NUEVO: Leer active_side del status
                
                // üÜï DETECTAR "NO HAY USUARIO" - pose_detected=false (NO usar confidence)
                // ‚ö†Ô∏è IMPORTANTE: orientation_confidence=0 solo significa orientaci√≥n incorrecta, NO ausencia de usuario
                if (!poseDetected) {
                    noUserCount++
                    
                    if (attemptCount % 5 === 1) {
                        console.warn(`üö´ [NO USER] No hay pose detectada`);
                        console.warn(`   Contador no-user: ${noUserCount}/${MAX_NO_USER_ATTEMPTS}`);
                    }
                    
                    // üõë SI NO HAY USUARIO POR 5 SEGUNDOS ‚Üí CANCELAR
                    if (noUserCount >= MAX_NO_USER_ATTEMPTS) {
                        clearInterval(checkInterval)
                        activeIntervals.delete(checkInterval)
                        
                        console.log('');
                        console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
                        console.log('‚ïë                          üö´üö´üö´ NO HAY USUARIO DETECTADO üö´üö´üö´                        ‚ïë');
                        console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
                        console.log(`‚ïë ‚è±Ô∏è Tiempo esperando:  ${(elapsed/1000).toFixed(1)}s`.padEnd(93) + '‚ïë');
                        console.log(`‚ïë üî¢ Intentos sin user: ${noUserCount}/${MAX_NO_USER_ATTEMPTS}`.padEnd(93) + '‚ïë');
                        console.log(`‚ïë üìä pose_detected:     ${poseDetected}`.padEnd(93) + '‚ïë');
                        console.log('‚ïë                                                                                        ‚ïë');
                        console.log('‚ïë üõë ACCI√ìN: Cancelando an√°lisis por ausencia de usuario                                ‚ïë');
                        console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
                        console.log('');
                        
                        updateStatus('‚ùå No se detect√≥ usuario frente a la c√°mara', 'error')
                        
                        // üõë CANCELAR an√°lisis completamente
                        await cancelAnalysis('No hay usuario presente')
                        resolve(null)  // null = cancelado por falta de usuario
                        return
                    }
                    
                    // Mostrar mensaje cada 2 segundos
                    if (elapsed - lastFeedbackTime > FEEDBACK_INTERVAL) {
                        updateStatus('‚è≥ Esperando que te coloques frente a la c√°mara...', 'warning')
                        lastFeedbackTime = elapsed
                    }
                    
                    return  // Continuar esperando
                }
                
                // ‚úÖ HAY USUARIO - Resetear contador
                noUserCount = 0
                
                // üìä LOG DETALLADO cada 5 intentos
                if (attemptCount % 5 === 1) {
                    console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
                    console.log(`‚ïë [Intento ${attemptCount.toString().padEnd(3)}] COMPARACI√ìN DE ORIENTACI√ìN`);
                    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
                    console.log(`‚ïë üéØ Detectado: "${currentOrientation}" (long: ${currentOrientation.length})`);
                    console.log(`‚ïë üéØ Requerido: "${requiredNormalized}" (long: ${requiredNormalized.length})`);
                    console.log(`‚ïë üìä Confianza: ${confidence.toFixed(3)} / ${MIN_CONFIDENCE} (umbral)`);
                    console.log(`‚ïë üÜï Active side: ${activeSide || 'null'}`);  // üÜï NUEVO: Mostrar active_side
                    console.log(`‚ïë ‚úì Match orientaci√≥n: ${currentOrientation === requiredNormalized ? '‚úÖ S√ç' : '‚ùå NO'}`);
                    console.log(`‚ïë ‚úì Confianza OK: ${confidence >= MIN_CONFIDENCE ? '‚úÖ S√ç' : '‚ùå NO'}`);
                    console.log(`‚ïë ‚úì Active side OK: ${(requiredNormalized !== 'SAGITAL' || activeSide !== null) ? '‚úÖ S√ç' : '‚ùå NO (falta lado)'}`);
                    console.log(`‚ïë ‚è±Ô∏è Tiempo transcurrido: ${(elapsed/1000).toFixed(1)}s / ${(maxWaitTime/1000).toFixed(1)}s`);
                    console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
                }
                
                // Guardar √∫ltima detecci√≥n
                window.lastDetectedOrientation = currentOrientation
                
                // üÜï VALIDACI√ìN MODERNA: Rechazar si orientaci√≥n es "INCORRECTA" (facing_direction no coincide)
                if (currentOrientation === "INCORRECTA") {
                    console.log(`‚ö†Ô∏è [Intento ${attemptCount}] Orientaci√≥n INCORRECTA - mirando direcci√≥n equivocada`)
                    
                    // Audio feedback cada 2 segundos
                    if (elapsed - lastFeedbackTime > FEEDBACK_INTERVAL) {
                        const message = requiredNormalized === 'FRONTAL' 
                            ? 'üîÑ Gira para mirar DE FRENTE a la c√°mara'
                            : 'üîÑ Gira para mirar DE LADO (perfil)'
                        
                        updateStatus(message, 'warning')
                        
                        // ÔøΩ Audio espec√≠fico para facing_direction incorrecto
                        if (window.speechSynthesis) {
                            try {
                                const audioMsg = requiredNormalized === 'FRONTAL'
                                    ? 'Gira y mira de frente a la c√°mara'
                                    : 'Gira y ponte de perfil de lado'
                                
                                console.log(`üîä Audio orientaci√≥n incorrecta: "${audioMsg}"`)
                                window.speechSynthesis.cancel()
                                
                                const utterance = new SpeechSynthesisUtterance(audioMsg)
                                utterance.lang = 'es-ES'
                                utterance.rate = 1.15
                                window.speechSynthesis.speak(utterance)
                            } catch (audioError) {
                                console.warn('‚ö†Ô∏è Audio no disponible:', audioError)
                            }
                        }
                        
                        lastFeedbackTime = elapsed
                    }
                    
                    return  // Continuar esperando
                }
                
                // ‚úÖ ORIENTACI√ìN CORRECTA - Verificar ESTABILIDAD (NUEVO)
                // üÜï Para SAGITAL (perfil), tambi√©n verificar que active_side est√© definido
                const isOrientationValid = (currentOrientation === requiredNormalized && confidence >= MIN_CONFIDENCE) &&
                                          (requiredNormalized !== 'SAGITAL' || activeSide !== null)
                
                if (isOrientationValid) {
                    
                    // üÜï Primera vez en orientaci√≥n correcta ‚Üí Iniciar contador
                    if (stableOrientationStart === null) {
                        stableOrientationStart = Date.now()
                        const sideInfo = requiredNormalized === 'SAGITAL' ? ` (lado: ${activeSide})` : ''
                        console.log(`‚è±Ô∏è Orientaci√≥n correcta detectada${sideInfo} - esperando estabilidad (2s)...`)
                    }
                    
                    // üÜï Calcular tiempo de estabilidad
                    const stableDuration = Date.now() - stableOrientationStart
                    const remainingStability = Math.ceil((STABILITY_DURATION - stableDuration) / 1000)
                    
                    // üÜï Si ya lleva 2 segundos estable ‚Üí VALIDAR
                    if (stableDuration >= STABILITY_DURATION) {
                        clearInterval(checkInterval)
                        activeIntervals.delete(checkInterval)
                        
                        console.log('');
                        console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
                        console.log('‚ïë                           ‚úÖ‚úÖ‚úÖ VALIDACI√ìN EXITOSA ‚úÖ‚úÖ‚úÖ                           ‚ïë');
                        console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
                        console.log(`‚ïë üéØ Orientaci√≥n: ${currentOrientation.padEnd(30)} ‚îÇ ‚úÖ CORRECTA ‚ïë`);
                        console.log(`‚ïë üìä Confianza:   ${confidence.toFixed(3).padEnd(30)} ‚îÇ ‚úÖ ALTA     ‚ïë`);
                        console.log(`‚ïë ‚è±Ô∏è Estabilidad: ${(stableDuration/1000).toFixed(1)}s`.padEnd(77) + '‚îÇ ‚úÖ OK       ‚ïë');
                        console.log(`‚ïë üî¢ Intentos:    ${attemptCount.toString().padEnd(30)} ‚îÇ‚ÑπÔ∏è  INFO     ‚ïë`);
                        console.log(`‚ïë ‚è±Ô∏è Tiempo:      ${(elapsed/1000).toFixed(1)}s`.padEnd(77) + '‚îÇ‚ÑπÔ∏è  INFO     ‚ïë');
                        console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
                        console.log('');
                        
                        updateStatus(`‚úÖ Orientaci√≥n confirmada (confianza: ${(confidence*100).toFixed(0)}%)`, 'success')
                        
                        // üîä Audio de confirmaci√≥n (√öNICO audio final)
                        if (window.speechSynthesis) {
                            try {
                                window.speechSynthesis.cancel()  // Cancelar cualquier audio previo
                                const utterance = new SpeechSynthesisUtterance('Muy bien, posici√≥n correcta')
                                utterance.lang = 'es-ES'
                                utterance.rate = 1.15
                                window.speechSynthesis.speak(utterance)
                            } catch (audioError) {
                                console.warn('‚ö†Ô∏è Audio no disponible:', audioError)
                            }
                        }
                        
                        resolve(true)
                        return
                    }
                    
                    // üÜï Todav√≠a no llega a 2s ‚Üí Mostrar progreso
                    updateStatus(`‚è≥ Mant√©n esta posici√≥n ${remainingStability}s m√°s...`, 'warning')
                    return
                }
                
                    // ‚ùå Orientaci√≥n incorrecta o confianza baja - Resetear contador
                if (stableOrientationStart !== null) {
                    const reason = !isOrientationValid ? 
                        (requiredNormalized === 'SAGITAL' && activeSide === null ? 'falta active_side' : 'orientaci√≥n perdida') 
                        : 'desconocido'
                    console.log(`‚ö†Ô∏è Orientaci√≥n perdida (${reason}) - reseteando contador de estabilidad`)
                    stableOrientationStart = null
                }                // ‚ö†Ô∏è ORIENTACI√ìN INCORRECTA - Dar feedback cada 2 segundos
                if (elapsed - lastFeedbackTime > FEEDBACK_INTERVAL) {
                    const message = requiredNormalized === 'FRONTAL' 
                        ? 'üîÑ Ponte de FRENTE a la c√°mara'
                        : 'üîÑ Ponte de PERFIL (lado) a la c√°mara'
                    
                    console.log(`‚ö†Ô∏è ${message} (detectado: ${currentOrientation}, conf: ${confidence.toFixed(2)})`)
                    console.log(`üìã Ejercicio: ${EXERCISE_CONFIG.exercise}, Orientaci√≥n requerida: ${EXERCISE_CONFIG.camera_orientation}`)
                    updateStatus(message, 'warning')
                    
                    // üîä Audio feedback - CORREGIDO: Leer del ejercicio, no hardcoded
                    if (window.speechSynthesis) {
                        try {
                            // üÜï LEER DEL CONFIG DEL EJERCICIO (camera_orientation: 'frontal' o 'sagital')
                            const audioMsg = requiredNormalized === 'FRONTAL'
                                ? 'Ponte de frente a la c√°mara'
                                : 'Ponte de perfil, de lado a la c√°mara'
                            
                            console.log(`üîä Reproduciendo audio: "${audioMsg}" (ejercicio: ${EXERCISE_CONFIG.exercise})`)
                            
                            // üõ°Ô∏è CANCELAR AUDIO ANTERIOR antes de hablar (evitar m√∫ltiples hilos)
                            window.speechSynthesis.cancel()
                            
                            const utterance = new SpeechSynthesisUtterance(audioMsg)
                            utterance.lang = 'es-ES'
                            utterance.rate = 1.15
                            window.speechSynthesis.speak(utterance)
                        } catch (audioError) {
                            console.warn('‚ö†Ô∏è Audio no disponible:', audioError)
                        }
                    }
                    
                    lastFeedbackTime = elapsed
                }
                
            } catch (error) {
                console.error('‚ùå [ORIENTATION] Error verificando orientaci√≥n:', error)
            }
            
        }, 500)  // Verificar cada 500ms
        
        // Agregar a activeIntervals para limpieza
        activeIntervals.add(checkInterval)
    })
}

/**
 * üë§ VALIDACI√ìN PRE-AN√ÅLISIS: Esperar detecci√≥n del usuario
 * Implementa Opci√≥n A CORREGIDA con 3 NIVELES DE DETECCI√ìN + STABILITY CHECK
 * 
 * FIXES APLICADOS:
 * - ‚úÖ Timeout reducido 30s ‚Üí 20s
 * - ‚úÖ Interval agregado a activeIntervals para limpieza correcta
 * - ‚úÖ Audio nativo (speechSynthesis) siempre
 * - ‚úÖ Validaci√≥n segment_visible (PERMISIVO) en lugar de points_visible
 * - ‚úÖ Feedback diferenciado: "no hay nadie" vs "hay alguien mal posicionado"
 * - ‚úÖ Logging detallado de 3 niveles
 * - üÜï STABILITY CHECK: Requiere 3 segundos de detecci√≥n estable antes de continuar
 */
async function waitForUserDetection() {
    console.log('üîç Iniciando validaci√≥n pre-an√°lisis (3 niveles + stability check 5s)...')
    
    const MAX_WAIT_TIME = 30000  // ‚úÖ FIX: 30 segundos m√°ximo (m√°s margen)
    const CHECK_INTERVAL = 500   // Verificar cada 500ms
    const STABILITY_DURATION = 5000  // ‚úÖ FIX: 5 segundos de detecci√≥n estable (evitar validaci√≥n r√°pida)
    
    const startTime = Date.now()
    let lastAudioAt = 0  // ‚úÖ Evitar audio repetido
    let stableDetectionStart = null  // üÜï Timestamp cuando empez√≥ detecci√≥n estable
    
    return new Promise((resolve, reject) => {
        const checkLoop = setInterval(async () => {
            try {
                // üì° Obtener estado de detecci√≥n del backend
                const statusResponse = await fetch(`/api/rom/status/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`)
                
                if (!statusResponse.ok) {
                    console.warn('‚ö†Ô∏è Error obteniendo status de detecci√≥n:', statusResponse.status)
                    return
                }
                
                const statusData = await statusResponse.json()
                const detectionInfo = statusData.status?.detection
                
                // üîç LOGGING DETALLADO DE 3 NIVELES
                console.log('üîç DEBUG 3 Niveles:', {
                    pose_detected: detectionInfo?.pose_detected,
                    segment_visible: detectionInfo?.segment_visible,
                    ready_for_analysis: detectionInfo?.ready_for_analysis,
                    confidence: detectionInfo?.confidence
                })
                
                // üÜï STABILITY CHECK: Requiere 3 segundos de detecci√≥n continua
                if (detectionInfo && detectionInfo.segment_visible === true) {
                    
                    // üÜï Primera vez detectado ‚Üí Iniciar contador
                    if (stableDetectionStart === null) {
                        stableDetectionStart = Date.now()
                        console.log('‚è±Ô∏è Detecci√≥n iniciada - esperando estabilidad (3s)...')
                    }
                    
                    // üÜï Calcular tiempo de estabilidad
                    const stableDuration = Date.now() - stableDetectionStart
                    const remainingStability = Math.ceil((STABILITY_DURATION - stableDuration) / 1000)
                    
                    // üÜï Si ya lleva 5 segundos estable ‚Üí Continuar
                    if (stableDuration >= STABILITY_DURATION) {
                        clearInterval(checkLoop)
                        activeIntervals.delete(checkLoop)
                        
                        console.log('‚úÖ Detecci√≥n ESTABLE por 5 segundos - Confianza:', detectionInfo.confidence)
                        updateStatus('‚úÖ Posici√≥n confirmada', 'success')
                        
                        // ÔøΩ Audio SILENCIADO - Se reproducir√° despu√©s en waitForCorrectOrientation()
                        // Evita duplicaci√≥n: "Posici√≥n confirmada" + "Muy bien, posici√≥n correcta"
                        console.log('üîá Audio de confirmaci√≥n omitido (se reproducir√° tras validar orientaci√≥n)')
                        
                        resolve(true)
                        return
                    }
                    
                    // üÜï Todav√≠a no llega a 5s ‚Üí Mostrar progreso
                    updateStatus(`‚è±Ô∏è Mant√©n la posici√≥n: ${remainingStability}s restantes...`, 'info')
                    return
                }
                
                // ‚ùå Ya NO est√° visible ‚Üí Resetear contador de estabilidad
                if (stableDetectionStart !== null) {
                    console.log('‚ö†Ô∏è Detecci√≥n perdida - reseteando contador de estabilidad')
                    stableDetectionStart = null
                }
                
                // ‚è±Ô∏è Verificar timeout
                const elapsed = Date.now() - startTime
                const remaining = Math.ceil((MAX_WAIT_TIME - elapsed) / 1000)
                
                if (elapsed > MAX_WAIT_TIME) {
                    clearInterval(checkLoop)
                    activeIntervals.delete(checkLoop)  // ‚úÖ LIMPIAR DE TRACKING
                    
                    console.error('‚ùå Timeout: No se detect√≥ segmento en 30 segundos')
                    
                    // üîä FEEDBACK DIFERENCIADO seg√∫n nivel de detecci√≥n
                    let errorMessage = ''
                    let voiceMessage = ''
                    
                    if (!detectionInfo || !detectionInfo.pose_detected) {
                        // NIVEL 1 FALL√ì: No hay nadie
                        errorMessage = '‚ùå No se detect√≥ persona'
                        voiceMessage = 'No se detect√≥ tu presencia. Por favor, posici√≥nate frente a la c√°mara.'
                    } else if (!detectionInfo.segment_visible) {
                        // NIVEL 2 FALL√ì: Hay alguien pero segmento no visible
                        errorMessage = '‚ùå Segmento no visible'
                        voiceMessage = 'Se detect√≥ movimiento pero no tu posici√≥n correcta. Ajusta tu posici√≥n frente a la c√°mara.'
                    } else {
                        // Fallback
                        errorMessage = '‚ùå No se complet√≥ la detecci√≥n'
                        voiceMessage = 'No se pudo completar la detecci√≥n. Intenta de nuevo.'
                    }
                    
                    updateStatus(errorMessage, 'error')
                    
                    try {
                        const utterance = new SpeechSynthesisUtterance(voiceMessage)
                        utterance.lang = 'es-ES'
                        utterance.rate = 1.15  // Aumentado para mensajes largos de error
                        window.speechSynthesis.speak(utterance)
                    } catch (audioError) {
                        console.warn('‚ö†Ô∏è Audio no disponible:', audioError)
                    }
                    
                    reject(new Error('Timeout: Usuario no detectado'))
                    return
                }
                
                // üì¢ Actualizar feedback visual seg√∫n nivel (con info de estabilidad)
                let feedbackMessage = ''
                if (!detectionInfo || !detectionInfo.pose_detected) {
                    feedbackMessage = `‚ö†Ô∏è No se detecta persona... (${remaining}s)`
                } else if (!detectionInfo.segment_visible) {
                    feedbackMessage = `‚ö†Ô∏è Ajusta tu posici√≥n... (${remaining}s)`
                } else if (stableDetectionStart !== null) {
                    // üÜï Detectado pero esperando estabilidad
                    const stableDuration = Date.now() - stableDetectionStart
                    const remainingStability = Math.ceil((STABILITY_DURATION - stableDuration) / 1000)
                    feedbackMessage = `‚è±Ô∏è Mant√©n la posici√≥n: ${remainingStability}s restantes...`
                } else {
                    feedbackMessage = `‚ö†Ô∏è Esperando detecci√≥n... (${remaining}s)`
                }
                
                updateStatus(feedbackMessage, 'warning')
                
                // üîä Gu√≠a de audio peri√≥dica (cada 8 segundos, SIN REPETIR)
                const currentTime = Date.now()
                if (currentTime - lastAudioAt >= 8000 && remaining < 20) {
                    lastAudioAt = currentTime  // ‚úÖ Marcar para evitar repetir
                    
                    try {
                        // üîá Cancelar audio anterior antes de hablar
                        if (window.speechSynthesis) {
                            window.speechSynthesis.cancel()
                        }
                        
                        let audioMessage = ''
                        if (!detectionInfo || !detectionInfo.pose_detected) {
                            audioMessage = 'Por favor, posici√≥nate frente a la c√°mara.'
                        } else if (!detectionInfo.segment_visible) {
                            audioMessage = 'Ajusta tu posici√≥n para que el segmento sea visible.'
                        } else if (stableDetectionStart !== null) {
                            // üÜï Audio cuando est√° detectado pero esperando estabilidad
                            audioMessage = 'Excelente. Mant√©n esa posici√≥n sin moverte.'
                        }
                        
                        if (audioMessage) {
                            const utterance = new SpeechSynthesisUtterance(audioMessage)
                            utterance.lang = 'es-ES'
                            utterance.rate = 1.1  // Velocidad moderada para gu√≠as peri√≥dicas (user feedback)
                            window.speechSynthesis.speak(utterance)
                        }
                    } catch (audioError) {
                        console.warn('‚ö†Ô∏è Audio peri√≥dico fall√≥:', audioError)
                    }
                }
                
            } catch (error) {
                console.error('‚ùå Error en loop de detecci√≥n:', error)
            }
        }, CHECK_INTERVAL)
        
        // ‚úÖ AGREGAR A TRACKING DE INTERVALS
        activeIntervals.add(checkLoop)
        
        // üîä Gu√≠a inicial (siempre con speechSynthesis nativo)
        try {
            if (window.speechSynthesis) {
                const utterance = new SpeechSynthesisUtterance('Por favor, posici√≥nate frente a la c√°mara para comenzar.')
                utterance.lang = 'es-ES'
                utterance.rate = 1.15  // Aumentado para mensaje inicial largo
                window.speechSynthesis.speak(utterance)
            }
        } catch (audioError) {
            console.warn('‚ö†Ô∏è Audio inicial fall√≥:', audioError)
        }
    })
}

// üÜï MANUAL START BUTTON SYSTEM
// Variable global para resolver la Promise cuando el usuario haga clic
let manualStartResolver = null

async function waitForManualStart() {
    console.log('‚è∏Ô∏è Esperando que el usuario presione el bot√≥n INICIAR AN√ÅLISIS...')
    
    return new Promise((resolve) => {
        // Guardar el resolver para que startManualAnalysis() pueda llamarlo
        manualStartResolver = resolve
    })
}

function startManualAnalysis() {
    console.log('‚úÖ Usuario presion√≥ INICIAR AN√ÅLISIS - Comenzando medici√≥n...')
    
    // Ocultar el bot√≥n
    const manualButton = document.getElementById('manualStartButton')
    if (manualButton) {
        manualButton.style.display = 'none'
    }
    
    // Resolver la Promise para continuar el flujo
    if (manualStartResolver) {
        manualStartResolver(true)
        manualStartResolver = null  // Limpiar
    }
    
    // Feedback visual y auditivo
    updateStatus('üöÄ Iniciando an√°lisis...', 'success')
    
    try {
        if (window.speechSynthesis) {
            window.speechSynthesis.cancel()  // Cancelar audio anterior
            const utterance = new SpeechSynthesisUtterance('Iniciando an√°lisis.')
            utterance.lang = 'es-ES'
            utterance.rate = 1.2
            window.speechSynthesis.speak(utterance)
        }
    } catch (audioError) {
        console.warn('‚ö†Ô∏è Audio de inicio fall√≥:', audioError)
    }
}

async function startAnalysis() {
    console.log('üöÄ Iniciando an√°lisis integrado (Normal + ROM)...')
    
    // üõ°Ô∏è VERIFICAR SI SISTEMA EST√Å OCUPADO
    if (isSystemBusy()) {
        console.log('‚ö†Ô∏è Sistema ocupado, an√°lisis rechazado')
        updateStatus('Sistema ocupado, intente nuevamente', 'warning')
        return false
    }
    
    // üîí BLOQUEAR NAVEGACI√ìN DURANTE AN√ÅLISIS
    disableNavigationDuringAnalysis()
    
    try {
        const processId = `analysis_${Date.now()}`
        if (!setAnalysisState('loading', processId)) {
            console.log('‚ö†Ô∏è No se pudo cambiar estado a loading')
            return false
        }
        
        // Cambiar interfaz - MOVER STREAM A MODAL Y ABRIR
        document.getElementById('initialMessage').style.display = 'none'
        document.getElementById('analysisInterface').style.display = 'block'
        
        // üé¨ MOVER STREAM AL MODAL
        const streamContainer = document.querySelector('.stream-container')
        const modalStreamContainer = document.getElementById('modalStreamContainer')
        if (streamContainer && modalStreamContainer) {
            modalStreamContainer.appendChild(streamContainer)
        }
        
        // üé¨ ABRIR MODAL
        document.getElementById('analysisModal').classList.add('active')
        
        document.getElementById('startAnalysisBtn').style.display = 'none'
        document.getElementById('runningButtons').style.display = 'inline-block'
        
        // üîç ACTUALIZAR INFO DE DEBUG (si el panel est√° visible)
        if (typeof updateDebugInfo === 'function') {
            updateDebugInfo();
        }
        
        updateStatus('Detectando c√°mara...', 'loading')
        
        // ÔøΩ FIX CR√çTICO: LEER LocalStorage/Cookie PRIMERO antes de cualquier detecci√≥n
        if (!selectedCameraInfo) {
            try {
                const storageKey = 'biomech_camera_settings';
                const savedData = localStorage.getItem(storageKey);
                
                if (savedData) {
                    const savedSettings = JSON.parse(savedData);
                    console.log('üì¶ Configuraci√≥n guardada encontrada:', savedSettings);
                    
                    // ‚úÖ VALIDAR que tenga deviceId v√°lido (N√öMERO, no string "undefined")
                    if (savedSettings.deviceId !== null && 
                        savedSettings.deviceId !== undefined && 
                        savedSettings.deviceId !== 'undefined' &&
                        savedSettings.deviceId !== 'auto') {
                        
                        const cameraId = typeof savedSettings.deviceId === 'number' 
                            ? savedSettings.deviceId 
                            : parseInt(savedSettings.deviceId, 10);
                        
                        if (!isNaN(cameraId)) {
                            selectedCameraInfo = {
                                success: true,
                                pythonCameraId: cameraId,
                                jsDeviceId: cameraId,
                                label: savedSettings.deviceLabel || 'C√°mara guardada',
                                deviceType: 'manual_selection',
                                source: 'LocalStorage'
                            };
                            
                            console.log('‚úÖ Usando c√°mara de LocalStorage:', selectedCameraInfo);
                        }
                    }
                }
                
                // üç™ FALLBACK: Si LocalStorage vac√≠o (InPrivate), leer cookie
                if (!selectedCameraInfo) {
                    const cookies = document.cookie.split(';');
                    const cameraCookie = cookies.find(c => c.trim().startsWith('biomech_camera='));
                    
                    if (cameraCookie) {
                        const cameraId = parseInt(cameraCookie.split('=')[1], 10);
                        
                        if (!isNaN(cameraId)) {
                            // Buscar label en otra cookie
                            const labelCookie = cookies.find(c => c.trim().startsWith('biomech_camera_label='));
                            const label = labelCookie 
                                ? decodeURIComponent(labelCookie.split('=')[1]) 
                                : 'C√°mara recuperada (cookie)';
                            
                            console.log(`üç™ Recuperando c√°mara desde cookie: ${cameraId}`);
                            
                            selectedCameraInfo = {
                                success: true,
                                pythonCameraId: cameraId,
                                jsDeviceId: cameraId,
                                label: label,
                                deviceType: 'cookie_recovery',
                                source: 'Cookie'
                            };
                        }
                    }
                }
                
                if (!selectedCameraInfo) {
                    console.log('‚ÑπÔ∏è No hay configuraci√≥n guardada, se usar√° auto-detecci√≥n');
                }
            } catch (storageError) {
                console.error('‚ùå Error leyendo LocalStorage/Cookie:', storageError);
            }
        }
        
        // ÔøΩüéØ REUSAR c√°mara ya detectada si existe
        if (selectedCameraInfo && selectedCameraInfo.success) {
            console.log('üîÑ Reusando c√°mara ya detectada:', selectedCameraInfo.label);
            
            // Configurar directamente sin redetectar
            const cameraUrl = `/api/set_preselected_camera/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`
            
            const response = await fetch(cameraUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    camera_id: selectedCameraInfo.pythonCameraId,
                    camera_info: selectedCameraInfo
                })
            })
            
            const result = await response.json()
            
        } else {
            // üì¶ USAR C√ÅMARAS PRE-CARGADAS (NO re-detectar)
            console.log('üì¶ No hay c√°mara manual, usando c√°maras pre-cargadas...');
            
            if (window.availableCameras && window.availableCameras.length > 0) {
                console.log(`‚úÖ ${window.availableCameras.length} c√°maras pre-cargadas disponibles:`, window.availableCameras);
                
                // Buscar c√°mara recomendada
                const recommended = window.availableCameras.find(cam => cam.recommended);
                const selectedCamera = recommended || window.availableCameras[0];
                
                selectedCameraInfo = {
                    success: true,
                    pythonCameraId: selectedCamera.id,
                    jsDeviceId: selectedCamera.id,
                    label: selectedCamera.name,
                    deviceType: 'pre_loaded',
                    source: 'PreLoad'
                };
                
                console.log('‚úÖ Usando c√°mara pre-cargada:', selectedCameraInfo);
                
                const cameraUrl = `/api/set_preselected_camera/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`;
                
                const response = await fetch(cameraUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        camera_id: selectedCameraInfo.pythonCameraId,
                        camera_info: selectedCameraInfo
                    })
                });
                
                const result = await response.json();
                console.log('‚úÖ C√°mara configurada:', result);
                
            } else {
                // üö® √öLTIMO RECURSO: Usar c√°mara 0 por defecto
                console.warn('‚ö†Ô∏è No hay c√°maras pre-cargadas, usando c√°mara 0 por defecto');
                
                selectedCameraInfo = {
                    success: true,
                    pythonCameraId: 0,
                    jsDeviceId: 0,
                    label: 'C√°mara predeterminada (ID 0)',
                    deviceType: 'default_fallback',
                    source: 'Fallback'
                };
                
                const cameraUrl = `/api/set_preselected_camera/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`;
                
                const response = await fetch(cameraUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        camera_id: 0,
                        camera_info: selectedCameraInfo
                    })
                });
                
                const result = await response.json();
                console.log('‚úÖ C√°mara predeterminada configurada:', result);
            }
        }
        
        // Inicializar stream
        await initializeStreamAnalysis()
        
        // üÜï INICIAR ROM TRACKING INTEGRADO AUTOM√ÅTICAMENTE
        // ‚úÖ FIX: Esperar 4 segundos para que stream inicialice y capture landmarks
        // Esto asegura que rom_tracker.last_landmarks est√© disponible antes de waitForUserDetection()
        await new Promise(resolve => setTimeout(resolve, 4000))
        
        try {
            await startIntegratedROMSequence()
        } catch (romError) {
            console.warn('‚ö†Ô∏è Error en ROM integrado:', romError)
            // NO fallar el an√°lisis normal por errores ROM
        }
        
        // üîì AN√ÅLISIS PRINCIPAL COMPLETADO
        console.log('‚úÖ An√°lisis principal completado')
        
    } catch (error) {
        console.error('‚ùå Error en startAnalysis:', error)
        setAnalysisState('stopped')
        updateStatus('Error iniciando an√°lisis', 'error')
        resetInterface()
    }
}

// =============================================================================
// üÜï INTEGRATED ROM SEQUENCE - UNIFICA AN√ÅLISIS NORMAL + ROM
// =============================================================================

async function startIntegratedROMSequence() {
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê')
    console.log('üöÄ INICIO COMPLETO DE AN√ÅLISIS ROM')
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê')
    console.log(`üìã Configuraci√≥n del ejercicio:`)
    console.log(`   - Segmento: ${EXERCISE_CONFIG.segment}`)
    console.log(`   - Ejercicio: ${EXERCISE_CONFIG.exercise}`)
    console.log(`   - Duraci√≥n: ${EXERCISE_CONFIG.duration_seconds}s`)
    console.log(`   - Orientaci√≥n requerida: ${EXERCISE_CONFIG.camera_orientation}`)
    console.log(`   - ROM window: ${EXERCISE_CONFIG.rom_capture_config?.rom_window_seconds || 2}s`)
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê')
    
    try {
        // 1. Mostrar overlay ROM sobre el stream actual
        console.log('üì∫ [PASO 1/11] Mostrando overlay ROM...')
        const overlay = document.getElementById('romOverlay')
        if (overlay) {
            overlay.style.display = 'block'
            updateOverlayStatus('Preparando an√°lisis...')
        }
        
        // 2. Inicializar ROM Session si no existe
        console.log('üéØ [PASO 2/11] Inicializando ROMSessionManager...')
        if (!romSession) {
            romSession = new ROMSessionManager(EXERCISE_CONFIG.segment, EXERCISE_CONFIG.exercise)
            console.log('   ‚úÖ ROMSessionManager creado')
        } else {
            console.log('   ‚ÑπÔ∏è ROMSessionManager ya exist√≠a')
        }
        
        // 3. Mostrar mensaje de preparaci√≥n
        console.log('üí¨ [PASO 3/11] Mensaje de preparaci√≥n inicial...')
        updateStatus('üßç Preparaci√≥n: Posici√≥nate correctamente...', 'warning')
        
        // 4. Esperar 3 segundos para que el usuario se posicione
        console.log('‚è±Ô∏è [PASO 4/11] Esperando 3s para que usuario se posicione...')
        await new Promise(resolve => setTimeout(resolve, 3000))
        
        // 5. Iniciar fase de posicionamiento autom√°ticamente
        console.log('üé¨ [PASO 5/11] Iniciando calibraci√≥n en backend...')
        updateStatus('üßç POSICIONAMIENTO: Mant√©n posici√≥n erguida', 'warning')
        updateOverlayStatus('Posici√≥nate')
        
        // Iniciar calibraci√≥n en backend
        const calibrationResponse = await fetch(`/api/rom/start_calibration/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'}
        })
        
        console.log(`üì° Respuesta start_calibration: ${calibrationResponse.status} ${calibrationResponse.ok}`)
        
        if (!calibrationResponse.ok) {
            const errorText = await calibrationResponse.text()
            console.error(`‚ùå Error start_calibration: ${errorText}`)
            throw new Error('Error iniciando calibraci√≥n')
        }
        
        const calibData = await calibrationResponse.json()
        console.log('‚úÖ start_calibration exitoso:', calibData)
        
        // ‚ö° PASO 6: INICIO MANUAL - NO esperar orientaci√≥n, usuario decide cu√°ndo est√° listo
        console.log('‚ö° [PASO 6/11] MODO MANUAL: Usuario controla inicio de an√°lisis')
        console.log('   ‚ÑπÔ∏è Orientaci√≥n NO validada autom√°ticamente - responsabilidad del usuario')
        
        // üÜï PASO 7: VALIDACI√ìN DE DETECCI√ìN DEL USUARIO
        console.log('üë§ [PASO 7/11] Esperando detecci√≥n del usuario...')
        try {
            await waitForUserDetection()
            console.log('‚úÖ Usuario detectado correctamente')
        } catch (error) {
            console.error('‚ùå Error en validaci√≥n de usuario:', error)
            updateStatus('‚ùå No se detect√≥ usuario. An√°lisis cancelado.', 'error')
            await stopAnalysisCompletely()
            return
        }
        
        // üÜï MOSTRAR BOT√ìN Y ESPERAR CLIC DEL USUARIO
        console.log('üéØ [PASO 8/11] Mostrando bot√≥n INICIAR AN√ÅLISIS - Esperando clic del usuario...')
        updateStatus('üëç LISTO: Presiona el bot√≥n verde para INICIAR', 'success')
        
        // Mostrar el bot√≥n
        const manualButton = document.getElementById('manualStartButton')
        if (manualButton) {
            manualButton.style.display = 'block'
        }
        
        // Esperar a que el usuario haga clic
        await waitForManualStart()
        
        console.log('‚úÖ Usuario hizo clic en INICIAR - Comenzando an√°lisis...')
        
        // üîä PASO 8: AUDIO DE POSICIONAMIENTO (DESPU√âS de validaciones)
        console.log('üîä [PASO 8/11] Reproduciendo instrucciones de posicionamiento...')
        updateStatus('üîä Escucha las instrucciones...', 'info')
        
        if (window.audioIntegrator) {
            console.log('üîä Triggering positioning phase audio...');
            window.audioIntegrator.triggerPositioningPhase();
        }
        
        // ‚è±Ô∏è ESPERAR a que termine el audio (t√≠picamente 5-8 segundos)
        console.log('‚è±Ô∏è Esperando 8s para audio de posicionamiento...')
        await new Promise(resolve => setTimeout(resolve, 8000))
        console.log('‚úÖ Audio de posicionamiento completado')
        
        // 9. Countdown de calibraci√≥n visible (SOLO despu√©s de detectar usuario + audio)
        console.log('‚è±Ô∏è [PASO 9/11] Countdown de calibraci√≥n (5s)...')
        let calibrationCountdown = 5
        const calibrationInterval = addInterval(setInterval(() => {
            if (calibrationCountdown > 0) {
                updateStatus(`üßç POSICIONAMIENTO: ${calibrationCountdown} segundos restantes...`, 'warning')
                updateOverlayStatus(`Posici√≥nate (${calibrationCountdown}s)`)
                calibrationCountdown--
            } else {
                clearInterval(calibrationInterval)
                activeIntervals.delete(calibrationInterval)
            }
        }, 1000))
        
        // 7. Esperar 5 segundos de posicionamiento
        await new Promise(resolve => setTimeout(resolve, 5000))
        
        // 8. Establecer referencia con √°ngulo neutral (posici√≥n anat√≥mica)
        console.log('üìê Estableciendo referencia anat√≥mica neutral...')
        console.log(`üì° Llamando /api/rom/calibrate/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`)
        const calibrateResponse = await fetch(`/api/rom/calibrate/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ angle: 0 })  // Posici√≥n anat√≥mica = 0¬∞
        })
        
        console.log(`üì° Respuesta calibrate: ${calibrateResponse.status} ${calibrateResponse.ok}`)
        
        if (!calibrateResponse.ok) {
            const errorText = await calibrateResponse.text()
            console.error(`‚ùå Error calibrate: ${errorText}`)
            throw new Error('Error estableciendo referencia')
        }
        
        const calibrateData = await calibrateResponse.json()
        console.log('‚úÖ Referencia establecida:', calibrateData)
        console.log('‚è±Ô∏è [PASO 10/11] Pausa de 2s antes de iniciar an√°lisis...')
        updateStatus(`‚úÖ Posici√≥n establecida. Iniciando an√°lisis de ${EXERCISE_CONFIG.duration_seconds} segundos...`, 'success')
        updateOverlayStatus('Activo')
        
        // 10. Pausa de 2 segundos antes del an√°lisis
        await new Promise(resolve => setTimeout(resolve, 2000))
        
        // 11. Iniciar sesi√≥n de medici√≥n autom√°ticamente
        console.log('üöÄ [PASO 11/11] Iniciando sesi√≥n ROM...')
        console.log(`üì° POST /api/rom/start_session/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`)
        updateStatus(`üèÉ‚Äç‚ôÇÔ∏è AN√ÅLISIS ROM: ¬°Realiza el ejercicio! (${EXERCISE_CONFIG.duration_seconds} segundos)`, 'success')
        
        const sessionResponse = await fetch(`/api/rom/start_session/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'}
        })
        
        console.log(`üì° Respuesta start_session: ${sessionResponse.status} ${sessionResponse.ok}`)
        
        if (!sessionResponse.ok) {
            const errorText = await sessionResponse.text()
            console.error(`‚ùå Error start_session: ${errorText}`)
            throw new Error('Error iniciando sesi√≥n ROM')
        }
        
        const sessionData = await sessionResponse.json()
        console.log('‚úÖ start_session exitoso:', sessionData)
        
        // üîä TRIGGER AUDIO: Exercise Phase
        if (window.audioIntegrator) {
            console.log('üîä Triggering exercise phase audio...');
            window.audioIntegrator.triggerExercisePhase();
        }
        
        // ‚úÖ USAR duraci√≥n configurada en exercises.json
        const ANALYSIS_DURATION = EXERCISE_CONFIG.duration_seconds || 14
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê')
        console.log(`‚è±Ô∏è INICIANDO AN√ÅLISIS POR ${ANALYSIS_DURATION} SEGUNDOS`)
        console.log(`   - Backend capture: ${ANALYSIS_DURATION}s`)
        console.log(`   - ROM window: ${EXERCISE_CONFIG.rom_capture_config?.rom_window_seconds || 5}s (√∫ltimos segundos)`)
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê')
        
        // 12. Iniciar timer visual Y MONITOREO ROM
        romSession.showOverlayTimer(ANALYSIS_DURATION)
        let measurementCountdown = ANALYSIS_DURATION
        
        // üÜï MONITOREO ROM EN TIEMPO REAL
        console.log('üìä Iniciando monitoreo ROM en tiempo real (cada 500ms)...')
        const romMonitoringInterval = addInterval(setInterval(async () => {
            try {
                const romResponse = await fetch(`/api/rom/status/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`)
                if (romResponse.ok) {
                    const romData = await romResponse.json()
                    if (romData.status) {
                        updateROMOverlayData(romData.status)
                    }
                }
            } catch (error) {
                // Silencioso - no spammear consola
            }
        }, 500))
        
        const measurementInterval = addInterval(setInterval(() => {
            if (measurementCountdown > 0) {
                // üéØ FEEDBACK ESPECIAL en √∫ltimos 5 segundos
                if (measurementCountdown <= 5 && measurementCountdown > 2) {
                    console.log(`‚ö° [COUNTDOWN ${measurementCountdown}s] √öltimos segundos - m√°ximo esfuerzo`)
                    updateStatus(`‚ö° ¬°√öLTIMOS ${measurementCountdown} SEGUNDOS! Da tu m√°ximo esfuerzo`, 'success')
                    romSession.showOverlayTimer(measurementCountdown)
                } else if (measurementCountdown <= 2) {
                    console.log(`üî• [COUNTDOWN ${measurementCountdown}s] Final - mantener posici√≥n`)
                    updateStatus(`üî• ¬°√öLTIMOS ${measurementCountdown} SEGUNDOS! Mant√©n la posici√≥n`, 'success')
                    romSession.showOverlayTimer(measurementCountdown)
                    
                    // üîä Audio en segundo 2
                    if (measurementCountdown === 2 && window.speechSynthesis) {
                        try {
                            const utterance = new SpeechSynthesisUtterance('¬°√öltimos 2 segundos!')
                            utterance.lang = 'es-ES'
                            utterance.rate = 1.3
                            utterance.volume = 0.8
                            window.speechSynthesis.speak(utterance)
                        } catch (e) {
                            console.warn('Audio no disponible:', e)
                        }
                    }
                } else {
                    updateStatus(`üèÉ‚Äç‚ôÇÔ∏è AN√ÅLISIS ROM: ${measurementCountdown} segundos restantes`, 'success')
                    romSession.showOverlayTimer(measurementCountdown)
                }
                measurementCountdown--
            } else {
                console.log('‚è±Ô∏è Countdown finalizado, limpiando intervalos...')
                clearInterval(measurementInterval)
                clearInterval(romMonitoringInterval)
                activeIntervals.delete(measurementInterval)
                activeIntervals.delete(romMonitoringInterval)
            }
        }, 1000))
        
        // 13. Esperar EXACTAMENTE la duraci√≥n del an√°lisis
        console.log(`‚è±Ô∏è Esperando ${ANALYSIS_DURATION} segundos...`)
        await new Promise(resolve => setTimeout(resolve, ANALYSIS_DURATION * 1000))
        console.log(`‚úÖ An√°lisis de ${ANALYSIS_DURATION}s completado`)
        
        // 14. Finalizar sesi√≥n autom√°ticamente
        console.log('‚èπÔ∏è Finalizando sesi√≥n ROM...')
        updateStatus('‚èπÔ∏è An√°lisis completado. Procesando resultados...', 'info')
        
        // üõ°Ô∏è VALIDAR QUE HAY SESI√ìN ACTIVA ANTES DE TERMINAR
        try {
            const statusCheck = await fetch(`/api/rom/status/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`)
            if (!statusCheck.ok) {
                console.log('‚ö†Ô∏è No hay sesi√≥n ROM activa para terminar')
                return
            }
            
            const statusData = await statusCheck.json()
            if (!statusData.status?.active) {
                console.log('‚ö†Ô∏è Sesi√≥n ROM ya terminada, saltando end_session')
                return
            }
        } catch (error) {
            console.log('‚ö†Ô∏è Error verificando estado ROM:', error)
            return
        }
        
        const endResponse = await fetch(`/api/rom/end_session/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'}
        })
        
        if (endResponse.ok) {
            const results = await endResponse.json()
            console.log('‚úÖ Resultados ROM:', results)
            
            // 14. Mostrar resultados en overlay
            if (results.success && results.results) {
                // üÜï MOSTRAR LADO DEL ROM M√ÅXIMO EN OVERLAY (no en status)
                const sideText = results.results.max_rom_side ? 
                    ` (${results.results.max_rom_side === 'derecho' ? 'Derecho' : 
                         results.results.max_rom_side === 'izquierdo' ? 'Izquierdo' : 
                         results.results.max_rom_side === 'ambos' ? 'Ambos' : ''})` : ''
                
                // üêõ DEBUG: Ver qu√© est√° pasando con el lado
                console.log('üêõ DEBUG ROM SIDE:')
                console.log('- max_rom_side:', results.results.max_rom_side)
                console.log('- sideText:', sideText)
                console.log('- max_rom_details:', results.results.max_rom_details)
                console.log('- results completos:', results.results)
                
                updateOverlayStatus('Finalizado')
                updateStatus(`‚úÖ An√°lisis ROM completado (${results.results.classification})`, 'success')
                
                // Mantener overlay con resultados finales COMPLETOS
                setTimeout(() => {
                    romSession.hideOverlayTimer()
                    
                    // üéØ MOSTRAR RESULTADO FINAL DIRECTAMENTE EN romMaxAngle
                    const maxAngleElement = document.getElementById('romMaxAngle')
                    if (maxAngleElement) {
                        const finalText = `${results.results.max_rom}¬∞${sideText}`
                        maxAngleElement.textContent = finalText
                        maxAngleElement.style.color = '#ffc107'
                    }
                    
                    // üìä ACTUALIZAR HISTORIAL AUTOM√ÅTICAMENTE despu√©s del an√°lisis
                    loadAnalysisHistory()
                    
                    // üîì LIBERAR SISTEMA - An√°lisis completado exitosamente
                    setAnalysisState('stopped')
                    
                    // üîì HABILITAR NAVEGACI√ìN despu√©s de an√°lisis
                    enableNavigationAfterAnalysis()
                    
                    // üé¨ CERRAR MODAL Y DETENER STREAM DESPU√âS DE 3 SEGUNDOS
                    setTimeout(() => {
                        stopAnalysisCompletely()  // Detiene stream
                    }, 3000)  // 3 segundos adicionales para ver resultados
                }, 3000)
            }
        }
        
        console.log('üéâ Secuencia ROM integrada completada')
        
    } catch (error) {
        console.error('‚ùå‚ùå‚ùå ERROR EN SECUENCIA ROM ‚ùå‚ùå‚ùå')
        console.error('Error:', error)
        console.error('Stack:', error.stack)
        updateStatus('‚ö†Ô∏è Error en an√°lisis ROM. Continuando an√°lisis normal...', 'warning')
        
        // Ocultar overlay en caso de error
        const overlay = document.getElementById('romOverlay')
        if (overlay) {
            overlay.style.display = 'none'
        }
        
        // üîì LIBERAR SISTEMA - Error en an√°lisis
        setAnalysisState('stopped')
        console.log('‚ö†Ô∏è Sistema liberado por error en ROM')
        
        // üîì HABILITAR NAVEGACI√ìN despu√©s de error
        enableNavigationAfterAnalysis()
    }
}

// Funci√≥n auxiliar para actualizar overlay status
function updateOverlayStatus(status) {
    // Usar elemento separado para estados del sistema
    const statusElement = document.getElementById('romStatusMessage')
    if (statusElement) {
        // Solo mostrar estados temporales, NO resultados finales
        if (status.includes('M√°ximo:')) {
            // Para resultados finales, ocultar mensaje de estado
            statusElement.style.display = 'none'
            return
        }
        
        // Mostrar estados temporales
        statusElement.textContent = status
        statusElement.style.display = 'block'
        
        const colors = {
            'Preparando an√°lisis...': '#ffc107',
            'Posici√≥nate (5s)': '#ffc107', 
            'Activo': '#28a745',
            'Finalizado': '#007bff'
        }
        
        if (status.includes('Posici√≥nate')) {
            statusElement.style.color = '#ffc107'
            statusElement.style.background = 'rgba(255, 193, 7, 0.1)'
        } else {
            const color = colors[status] || '#6c757d'
            statusElement.style.color = color
            statusElement.style.background = `rgba(${color === '#28a745' ? '40, 167, 69' : 
                                                     color === '#007bff' ? '0, 123, 255' : 
                                                     '108, 117, 125'}, 0.1)`
        }
    }
}

// üÜï FUNCI√ìN PARA ACTUALIZAR DATOS ROM EN OVERLAY
function updateROMOverlayData(romData) {
    console.log('üîç updateROMOverlayData recibi√≥:', romData) // DEBUG ACTIVADO
    
    // Actualizar √°ngulos actuales (derecho e izquierdo)
    const currentAngleElement = document.getElementById('romCurrentAngle')
    const maxAngleElement = document.getElementById('romMaxAngle')
    
    if (romData && currentAngleElement && maxAngleElement) {
        // Obtener √°ngulos de hombro derecho e izquierdo
        const rightAngle = romData.current_right_angle || 0
        const leftAngle = romData.current_left_angle || 0
        const maxROM = romData.max_rom || romData.current_max || 0
        const activeSide = romData.active_side  // üÜï 'right', 'left', o null (FRONTAL)
        
        console.log(`üîç √Ångulos: Right=${rightAngle}, Left=${leftAngle}, Max=${maxROM}, Active=${activeSide}`) // DEBUG
        
        // üÜï L√ìGICA INTELIGENTE: Mostrar seg√∫n vista (PERFIL vs FRONTAL)
        let displayText = ''
        
        // üéØ PRIORIDAD 1: Si hay active_side definido (PERFIL), SOLO mostrar ese lado
        if (activeSide === 'right') {
            // PERFIL DERECHO: Usuario muestra su brazo derecho
            displayText = `Derecho: ${rightAngle.toFixed(1)}¬∞`
        } else if (activeSide === 'left') {
            // PERFIL IZQUIERDO: Usuario muestra su brazo izquierdo
            displayText = `Izquierdo: ${leftAngle.toFixed(1)}¬∞`
        } else if (activeSide === null || activeSide === undefined) {
            // üåê FRONTAL (abducci√≥n): Mostrar ambos lados
            // ‚úÖ Backend ya corrigi√≥ el espejo, entonces rightAngle = derecho, leftAngle = izquierdo
            if (rightAngle > 0 && leftAngle > 0) {
                displayText = `D: ${rightAngle.toFixed(1)}¬∞ | I: ${leftAngle.toFixed(1)}¬∞`
            } else if (rightAngle > 0) {
                displayText = `Derecho: ${rightAngle.toFixed(1)}¬∞`
            } else if (leftAngle > 0) {
                displayText = `Izquierdo: ${leftAngle.toFixed(1)}¬∞`
            } else {
                displayText = '0¬∞'
            }
        }
        
        currentAngleElement.textContent = displayText
        maxAngleElement.textContent = `${maxROM.toFixed(1)}¬∞`
        
        console.log(`üìä ROM actualizado: ${displayText} | Max: ${maxROM.toFixed(1)}¬∞`) // DEBUG ACTIVADO
    } else {
        console.log('‚ö†Ô∏è No se pudo actualizar ROM - elementos o datos faltantes') // DEBUG ACTIVADO
    }
}

// =============================================================================
// üõë CANCEL ANALYSIS - Detener an√°lisis y limpiar recursos
// =============================================================================

async function cancelAnalysis(reason = 'Usuario cancel√≥') {
    console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
    console.log('‚ïë                          üõëüõëüõë CANCELANDO AN√ÅLISIS üõëüõëüõë                           ‚ïë');
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log(`‚ïë üìù Raz√≥n: ${reason.padEnd(80)}‚ïë`);
    console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
    
    try {
        // üé• PASO 1: Detener streaming de video
        console.log('üé• [1/5] Deteniendo streaming de video...');
        if (currentStreamImg) {
            currentStreamImg.src = '';  // Detener carga de im√°genes
        }
        
        // üìπ PASO 2: Detener c√°mara del cliente si est√° activa
        console.log('üìπ [2/5] Deteniendo c√°mara del cliente...');
        if (window.clientCameraHandler && window.clientCameraHandler.isActive) {
            await window.clientCameraHandler.stopCamera();
            console.log('   ‚úÖ C√°mara del cliente detenida');
        }
        
        // üîä PASO 3: Detener audio TTS
        console.log('üîä [3/5] Deteniendo audio TTS...');
        if (window.speechSynthesis && window.speechSynthesis.speaking) {
            window.speechSynthesis.cancel();
            console.log('   ‚úÖ Audio TTS detenido');
        }
        
        // ‚è±Ô∏è PASO 4: Limpiar intervals y timeouts
        console.log('‚è±Ô∏è [4/5] Limpiando intervals y timeouts...');
        if (window.activeIntervals && window.activeIntervals.size > 0) {
            window.activeIntervals.forEach(interval => {
                clearInterval(interval);
            });
            window.activeIntervals.clear();
            console.log(`   ‚úÖ ${window.activeIntervals.size} intervals limpiados`);
        }
        if (window.activeTimeouts && window.activeTimeouts.size > 0) {
            window.activeTimeouts.forEach(timeout => {
                clearTimeout(timeout);
            });
            window.activeTimeouts.clear();
            console.log(`   ‚úÖ ${window.activeTimeouts.size} timeouts limpiados`);
        }
        
        // üóÑÔ∏è PASO 5: Cancelar sesi√≥n ROM en backend
        console.log('üóÑÔ∏è [5/5] Cancelando sesi√≥n ROM en backend...');
        try {
            const cancelResponse = await fetch(
                `/api/rom/cancel/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`,
                { method: 'POST' }
            );
            
            if (cancelResponse.ok) {
                const result = await cancelResponse.json();
                console.log('   ‚úÖ Sesi√≥n ROM cancelada en backend:', result);
            } else {
                console.warn('   ‚ö†Ô∏è Backend no pudo cancelar sesi√≥n:', cancelResponse.status);
            }
        } catch (backendError) {
            console.warn('   ‚ö†Ô∏è Error al cancelar en backend:', backendError.message);
        }
        
        // ‚úÖ PASO 6: Resetear interfaz
        console.log('üîÑ [6/6] Reseteando interfaz...');
        resetROMInterface();
        
        console.log('');
        console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
        console.log('‚ïë                        ‚úÖ AN√ÅLISIS CANCELADO EXITOSAMENTE ‚úÖ                          ‚ïë');
        console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
        console.log('');
        
        updateStatus(`üõë An√°lisis cancelado: ${reason}`, 'error');
        
    } catch (error) {
        console.error('‚ùå Error durante cancelaci√≥n:', error);
        // A√∫n as√≠ intentar resetear interfaz
        resetROMInterface();
    }
}

// =============================================================================
// üÜï ROM ANALYSIS FUNCTIONS
// =============================================================================

function resetROMInterface() {
    // Mostrar interfaz inicial
    document.getElementById('initialMessage').style.display = 'block';
    document.getElementById('analysisInterface').style.display = 'none';
    document.getElementById('rom-session-container').style.display = 'none';
    
    // Resetear botones
    document.getElementById('startAnalysisBtn').style.display = 'inline-block';
    document.getElementById('runningButtons').style.display = 'none';
    
    // Limpiar ROM session
    if (romSession) {
        romSession = null;
    }
}

async function initializeStreamAnalysis() {
    try {
        updateStatus('Iniciando stream...', 'loading')
        
        // ÔøΩ INICIAR POLLING ROM (para mostrar √°ngulos actuales en overlay siempre)
        const romMonitoringInterval = addInterval(setInterval(async () => {
            try {
                const romResponse = await fetch(`/api/rom/status/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`)
                if (romResponse.ok) {
                    const romData = await romResponse.json()
                    if (romData.status) {
                        updateROMOverlayData(romData.status)
                    }
                }
            } catch (error) {
                // Silent fail - no molestar al usuario
            }
        }, 500)) // Actualizar cada 500ms
        
        // ÔøΩüåç VERIFICAR ENTORNO Y INICIAR C√ÅMARA DEL CLIENTE SI ES NECESARIO
        if (window.clientCameraHandler && window.clientCameraHandler.environmentInfo) {
            const envInfo = window.clientCameraHandler.environmentInfo;
            console.log('üåç Entorno detectado:', envInfo);
            
            if (envInfo.camera_mode === 'client_side') {
                updateStatus('Inicializando c√°mara del cliente...', 'loading')
                console.log('üì° Modo Railway: Iniciando c√°mara del cliente');
                
                // üéØ PASAR jsDeviceId de la c√°mara detectada
                const cameraStarted = await window.clientCameraHandler.startCamera(
                    EXERCISE_CONFIG.segment, 
                    EXERCISE_CONFIG.exercise,
                    selectedCameraInfo?.jsDeviceId  // üéØ USAR CAMO DeviceId
                );
                
                if (!cameraStarted) {
                    throw new Error('No se pudo inicializar la c√°mara del cliente');
                }
                
                updateStatus('C√°mara del cliente iniciada', 'loading');
                console.log('‚úÖ C√°mara del cliente iniciada correctamente');
            } else {
                console.log('üì∑ Modo local: Usando c√°mara del servidor');
            }
        } else {
            console.warn('‚ö†Ô∏è ClientCameraHandler no disponible, asumiendo modo servidor');
        }
        
        const streamUrl = `/api/stream/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}?t=${Date.now()}`
        console.log('üéØ Stream URL:', streamUrl)
        
        const streamImg = document.getElementById('analysisStream')
        currentStreamImg = streamImg
        
        // ‚úÖ ARREGLO: Cambiar estado ANTES de configurar onload
        analysisState = 'running'
        
        streamImg.onload = function() {
            console.log('üéØ Stream onload ejecutado, estado actual:', analysisState)
            
            // ‚úÖ ARREGLO: Verificar estado correcto O simplemente ejecutar
            if (analysisState === 'running' || analysisState === 'loading') {
                document.getElementById('loadingMessage').style.display = 'none'
                streamImg.style.display = 'block'
                updateStatus('An√°lisis biomec√°nico activo', 'active')
                updateStreamStatus('Stream conectado')
                console.log('‚úÖ Stream iniciado exitosamente - Botones deber√≠an estar visibles')
                
                // ‚úÖ VERIFICACI√ìN EXPL√çCITA: Asegurar que botones est√©n visibles
                const runningButtons = document.getElementById('runningButtons')
                if (runningButtons) {
                    runningButtons.style.display = 'inline-block'
                    console.log('‚úÖ Botones de control forzados a visible')
                } else {
                    console.error('‚ùå Elemento runningButtons no encontrado')
                }
                
                // üÜï SESSION 3 FIX: Ocultar bot√≥n de retry y mensajes cuando stream inicia correctamente
                const retryBtn = document.getElementById('camera-retry-button');
                if (retryBtn) {
                    console.log('üóëÔ∏è Removiendo bot√≥n de retry - stream exitoso');
                    retryBtn.remove();
                }
                
                // Ocultar mensaje de estado de c√°mara
                const cameraStatusMsg = document.getElementById('camera-status-message');
                if (cameraStatusMsg && cameraStatusMsg.style.display !== 'none') {
                    console.log('üóëÔ∏è Ocultando mensaje de estado de c√°mara');
                    cameraStatusMsg.style.opacity = '0';
                    setTimeout(() => {
                        cameraStatusMsg.style.display = 'none';
                        cameraStatusMsg.style.opacity = '1';
                    }, 300);
                }
            } else {
                console.warn('‚ö†Ô∏è Estado incorrecto en onload:', analysisState)
            }
        }
        
        streamImg.onerror = function(event) {
            // üõ°Ô∏è PREVENIR INFINITE LOOP durante reset
            if (analysisState === 'resetting' || streamImg.src === '') {
                console.log('üõ°Ô∏è Error ignorado durante reset/cleanup')
                return
            }
            
            console.error('üö®üö®üö® ERROR CR√çTICO EN streamImg.onerror üö®üö®üö®')
            console.error('‚ùå Error stream URL:', streamUrl)
            console.error('‚ùå Error event:', event)
            console.error('‚ùå streamImg.src actual:', streamImg.src)
            console.error('‚ùå streamImg.naturalWidth:', streamImg.naturalWidth)
            console.error('‚ùå streamImg.naturalHeight:', streamImg.naturalHeight)
            console.error('‚ùå streamImg.complete:', streamImg.complete)
            console.error('üö®üö®üö® FIN ERROR CR√çTICO üö®üö®üö®')
            retryConnection()
        }
        
        // ‚úÖ CONFIGURAR source DESPU√âS de configurar eventos
        streamImg.src = streamUrl
        
        // ‚öïÔ∏è SESSION 3: INICIAR MONITOREO DE SALUD DEL STREAM
        if (window.streamHealthMonitor) {
            console.log('‚öïÔ∏è Iniciando monitoreo de salud del stream...')
            window.streamHealthMonitor.startMonitoring(streamImg)
        } else {
            console.warn('‚ö†Ô∏è StreamHealthMonitor no disponible')
        }
        
    } catch (error) {
        console.error('‚ùå Error inicializando stream:', error)
        retryConnection()
    }
}

// =============================================================================
// üéÆ FUNCIONES DE CONTROL
// =============================================================================

function closeAnalysisModalManual(event) {
    event.stopPropagation()
    
    // Confirmar con usuario
    if (confirm('¬øDeseas detener el an√°lisis actual?')) {
        stopAnalysisCompletely()
    }
}

function pauseAnalysis() {
    console.log('‚è∏Ô∏è Pausando an√°lisis...')
    analysisState = 'paused'
    updateStatus('An√°lisis pausado', 'paused')
    
    document.getElementById('pauseAnalysisBtn').style.display = 'none'
    
    const resumeBtn = document.createElement('button')
    resumeBtn.id = 'resumeAnalysisBtn'
    resumeBtn.className = 'hero-button primary'
    resumeBtn.innerHTML = '<i class="bi bi-play-circle"></i> Reanudar'
    resumeBtn.onclick = resumeAnalysis
    
    const runningButtons = document.getElementById('runningButtons')
    if (runningButtons) {
        runningButtons.insertBefore(resumeBtn, document.getElementById('stopAnalysisBtn'))
    }
}

function resumeAnalysis() {
    console.log('‚ñ∂Ô∏è Reanudando an√°lisis...')
    analysisState = 'running'
    updateStatus('An√°lisis activo', 'active')
    
    const resumeBtn = document.getElementById('resumeAnalysisBtn')
    if (resumeBtn) {
        resumeBtn.remove()
    }
    
    document.getElementById('pauseAnalysisBtn').style.display = 'inline-block'
}

function stopAnalysisCompletely() {
    console.log('‚èπÔ∏è Deteniendo an√°lisis...')
    analysisState = 'stopped'
    
    // ‚öïÔ∏è SESSION 3: DETENER MONITOREO DE SALUD DEL STREAM
    if (window.streamHealthMonitor) {
        console.log('‚öïÔ∏è Deteniendo monitoreo de salud del stream...')
        window.streamHealthMonitor.stopMonitoring()
    }
    
    // üîá DETENER AUDIO INMEDIATAMENTE (antes de cualquier otra cosa)
    if (window.speechSynthesis) {
        window.speechSynthesis.cancel();
        console.log('üîá speechSynthesis cancelado inmediatamente');
    }
    
    // üõë LIMPIAR TODOS LOS INTERVALS ACTIVOS (incluye validation loop)
    console.log(`üõë Limpiando ${activeIntervals.size} intervals activos...`);
    activeIntervals.forEach(intervalId => {
        clearInterval(intervalId);
    });
    activeIntervals.clear();
    
    try {
        const stopUrl = `/api/stop_stream/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`
        
        fetch(stopUrl, { method: 'POST' })
            .then(response => response.json())
            .then(data => console.log('‚úÖ Stream detenido:', data))
            .catch(error => console.warn('‚ö†Ô∏è Error deteniendo stream:', error))
        
    } catch (error) {
        console.warn('‚ö†Ô∏è Error en stop request:', error)
    }
    
    // üé• DETENER C√ÅMARA DEL CLIENTE SI EST√Å ACTIVA
    if (window.clientCameraHandler && window.clientCameraHandler.isStreaming) {
        console.log('üì° Deteniendo c√°mara del cliente...');
        window.clientCameraHandler.stopCamera();
    }
    
    // üîä DETENER SISTEMA DE AUDIO
    if (window.audioGuideSystem && typeof window.audioGuideSystem.stop === 'function') {
        console.log('üîá Deteniendo sistema de audio...');
        window.audioGuideSystem.stop();
    }
    
    resetInterface()
    
    // ÔøΩ NO cargar historial en stop - solo en completado exitoso
}

function retryConnection() {
    console.log('üîÑ Reintentando conexi√≥n...')
    
    // üõ°Ô∏è PREVENIR RETRY SI ESTAMOS EN RESET O PARADO
    if (analysisState === 'resetting' || analysisState === 'stopped') {
        console.log('üõ°Ô∏è Retry bloqueado - estado:', analysisState)
        return
    }
    
    stopAnalysisCompletely()
    
    setTimeout(() => {
        if (analysisState === 'stopped') {
            startAnalysis()
        }
    }, 2000)
}

function saveAnalysis() {
    console.log('üíæ Guardando an√°lisis...')
    updateStatus('Guardando...', 'loading')
    
    setTimeout(() => {
        updateStatus('Guardado exitosamente', 'active')
    }, 1000)
}

function resetAnalysis() {
    console.log('üîÑ Reset ligero ROM (manteniendo c√°mara)...')
    
    // üõ°Ô∏è CONTROL ROBUSTO DE RESET  
    if (isSystemBusy()) {
        console.log('‚ö†Ô∏è Sistema ocupado, reset rechazado')
        return false
    }
    
    // üîí Bloquear sistema INMEDIATAMENTE
    isResetInProgress = true
    
    // üõ°Ô∏è PREVENIR M√öLTIPLES CLICS EN RESET
    const resetBtn = document.querySelector('button[onclick="resetAnalysis()"]')
    if (resetBtn) {
        resetBtn.disabled = true
        resetBtn.textContent = 'Reiniciando...'
    }
    
    // üßπ LIMPIAR SOLO INTERVALOS ROM - NO TOCAR C√ÅMARA
    clearAllIntervals()
    
    // üö® LIMPIAR ROM SESSION BACKEND (SIN ERROR EN CONSOLE)
    try {
        // Solo intentar si hay session activa
        if (window.romSession && window.romSession.isActive) {
            fetch(`/api/rom/end_session/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'}
            }).catch(() => {
                // Silencioso - no contaminar console
            })
        }
    } catch (error) {
        // Ignorar silenciosamente
    }
    
    // üö® RESET ROM SESSION MANAGER  
    if (window.romSession) {
        try {
            window.romSession.stopMeasurement()
            window.romSession.reset()
        } catch (e) {
            console.log('‚ö†Ô∏è Error limpiando ROM session:', e)
        }
    }
    
    // üéØ RESET SOLO UI ROM - MANTENER C√ÅMARA INTACTA
    const overlay = document.getElementById('romOverlay')
    if (overlay) {
        overlay.style.display = 'none'
    }
    
    const statusMessage = document.getElementById('romStatusMessage')
    if (statusMessage) {
        statusMessage.style.display = 'none'
        statusMessage.textContent = ''
    }
    
    // üîÑ LIMPIAR DISPLAY ROM
    const romCurrentAngle = document.getElementById('romCurrentAngle')
    const romMaxAngle = document.getElementById('romMaxAngle')
    if (romCurrentAngle) romCurrentAngle.textContent = '0¬∞'
    if (romMaxAngle) romMaxAngle.textContent = '0¬∞'
    
    // ÔøΩ REHABILITAR SISTEMA R√ÅPIDAMENTE
    isResetInProgress = false
    if (resetBtn) {
        resetBtn.disabled = false
        resetBtn.textContent = 'Reiniciar An√°lisis'
    }
    
    console.log('‚úÖ Reset ROM completado - Reactivando solo ROM...')
    
    // ÔøΩ REINICIAR SOLO ROM - SIN TOCAR C√ÅMARA
    setTimeout(async () => {
        if (!isSystemBusy()) {
            console.log('üî• Reactivando ROM desde conteo (c√°mara ya lista)...')
            try {
                await startIntegratedROMSequence()
            } catch (error) {
                console.error('‚ùå Error reactivando ROM:', error)
                updateStatus('‚ö†Ô∏è Error reactivando ROM', 'warning')
            }
        }
    }, 300)  // Reset r√°pido - c√°mara ya funciona
}


        

        
        // ÔøΩÔ∏è REHABILITAR BOT√ìN RESET


        
        // ÔøΩüöÄ AUTO-REINICIAR AN√ÅLISIS despu√©s del reset



// =============================================================================
// üìä FUNCIONES DE HISTORIAL
// =============================================================================

async function loadAnalysisHistory() {
    // üõ°Ô∏è PREVENIR M√öLTIPLES LLAMADAS CONCURRENTES
    if (isLoadingHistory) {
        console.log('‚ö†Ô∏è Ya se est√° cargando el historial, saltando...')
        return
    }
    
    isLoadingHistory = true
    
    try {
        console.log('üìä Cargando historial de an√°lisis...')
        
        const response = await fetch(`/api/analysis/history/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`)
        const data = await response.json()
        const historyContainer = document.getElementById('analysisHistory')
        
        // üõ°Ô∏è MANEJO DEFENSIVO DE RESPUESTAS
        if (data.success === false) {
            console.warn('‚ö†Ô∏è Backend report√≥ error:', data.error)
            historyContainer.innerHTML = '<p class="text-muted">No hay an√°lisis previos disponibles</p>'
            return
        }
        
        if (!data.history || data.history.length === 0) {
            historyContainer.innerHTML = '<p class="text-muted p-3" style="text-align: center;">No hay an√°lisis previos para este ejercicio</p>'
            document.getElementById('romStats').innerHTML = '<p class="text-muted" style="text-align: center;">Realizar an√°lisis para ver estad√≠sticas...</p>'
            return
        }
        
        let historyHTML = ''
        
        data.history.forEach((analysis, index) => {
            try {
                const date = new Date(analysis.date).toLocaleDateString('es-ES')
                const time = new Date(analysis.date).toLocaleTimeString('es-ES', {hour: '2-digit', minute: '2-digit'})
                const maxRom = analysis.max_rom || 0
                const romSide = analysis.max_rom_side || 'ninguno'  // üÜï Lado ROM
                const classification = analysis.rom_classification || 'unknown'
                const quality = analysis.quality_score || 0
                const duration = analysis.duration || 0
                
                // BILATERAL: Obtener detalles de ambos lados (si existen)
                const maxRomDetails = analysis.max_rom_details || null
                const exerciseName = analysis.exercise_name || EXERCISE_CONFIG.exercise
                
                // FUNCI√ìN HELPER: Normalizar texto (remover tildes y convertir a min√∫sculas)
                const normalizeText = (text) => {
                    if (!text) return ''
                    return text.toLowerCase()
                        .normalize('NFD')  // Descomponer caracteres Unicode
                        .replace(/[\u0300-\u036f]/g, '')  // Remover marcas diacr√≠ticas (tildes)
                }
                
                // ABDUCTION es bilateral (case-insensitive, sin tildes, espa√±ol/ingl√©s)
                const normalizedName = normalizeText(exerciseName)
                const isBilateral = normalizedName.includes('abduction') || normalizedName.includes('abduccion')
                
                // DEBUG: Log de TODOS los an√°lisis para diagn√≥stico
                console.log(`HISTORIAL ITEM #${index}:`, {
                    id: analysis.id,
                    exerciseName,
                    normalizedName,  // Agregar nombre normalizado para ver transformaci√≥n
                    isBilateral,
                    hasMaxRomDetails: !!maxRomDetails,
                    maxRomDetails,
                    maxRom,
                    romSide
                })
                
                // DEBUG: Ver datos recibidos para abduction
                if (isBilateral) {
                    console.log('DEBUG ABDUCTION:', {
                        exerciseName,
                        hasMaxRomDetails: !!maxRomDetails,
                        maxRomDetails,
                        maxRom,
                        romSide
                    })
                }
                
                // COLORES BIOMEC√ÅNICOS SEG√öN CLASIFICACI√ìN
                const getClassificationStyle = (classification) => {
                    const styles = {
                        '√≥ptimo': { bg: 'rgba(16, 185, 129, 0.15)', border: 'rgba(16, 185, 129, 0.4)', text: '#10B981', shadow: '0 0 10px rgba(16, 185, 129, 0.3)' },
                        'bueno': { bg: 'rgba(0, 212, 255, 0.15)', border: 'rgba(0, 212, 255, 0.4)', text: '#00D4FF', shadow: '0 0 10px rgba(0, 212, 255, 0.3)' },
                        'necesita mejorar': { bg: 'rgba(255, 165, 0, 0.15)', border: 'rgba(255, 165, 0, 0.4)', text: '#FFA500', shadow: '0 0 10px rgba(255, 165, 0, 0.3)' },
                        'limitado': { bg: 'rgba(239, 68, 68, 0.15)', border: 'rgba(239, 68, 68, 0.4)', text: '#EF4444', shadow: '0 0 10px rgba(239, 68, 68, 0.3)' },
                        'optimal': { bg: 'rgba(16, 185, 129, 0.15)', border: 'rgba(16, 185, 129, 0.4)', text: '#10B981', shadow: '0 0 10px rgba(16, 185, 129, 0.3)' },
                        'good': { bg: 'rgba(0, 212, 255, 0.15)', border: 'rgba(0, 212, 255, 0.4)', text: '#00D4FF', shadow: '0 0 10px rgba(0, 212, 255, 0.3)' },
                        'needs_work': { bg: 'rgba(255, 165, 0, 0.15)', border: 'rgba(255, 165, 0, 0.4)', text: '#FFA500', shadow: '0 0 10px rgba(255, 165, 0, 0.3)' },
                        'limited': { bg: 'rgba(239, 68, 68, 0.15)', border: 'rgba(239, 68, 68, 0.4)', text: '#EF4444', shadow: '0 0 10px rgba(239, 68, 68, 0.3)' }
                    }
                    return styles[classification] || { bg: 'rgba(148, 163, 184, 0.15)', border: 'rgba(148, 163, 184, 0.4)', text: '#94A3B8', shadow: 'none' }
                }
                
                const style = getClassificationStyle(classification)
                
                // üÜï L√ìGICA BILATERAL: Mostrar ambos lados o solo el activo
                let romDisplayHTML = ''
                if (isBilateral && maxRomDetails && (maxRomDetails.right > 0 || maxRomDetails.left > 0)) {
                    // ‚úÖ ABDUCTION: Mostrar ambos brazos con iconos claros
                    romDisplayHTML = `
                        <div style="display: flex; flex-direction: column; gap: 0.3rem;">
                            <strong style="color: var(--biomech-cyan); font-size: 1.1rem; text-shadow: 0 0 8px rgba(0, 212, 255, 0.3);">
                                ROM Bilateral:
                            </strong>
                            <div style="display: flex; gap: 1rem; font-size: 0.95rem; margin-top: 0.2rem;">
                                <span style="color: var(--biomech-text-secondary);">
                                    <i class="bi bi-arrow-right-circle-fill" style="color: #FFD700;"></i> Derecho: <strong style="color: var(--biomech-cyan);">${maxRomDetails.right.toFixed(1)}¬∞</strong>
                                </span>
                                <span style="color: var(--biomech-text-secondary);">
                                    <i class="bi bi-arrow-left-circle-fill" style="color: #FF6B6B;"></i> Izquierdo: <strong style="color: var(--biomech-cyan);">${maxRomDetails.left.toFixed(1)}¬∞</strong>
                                </span>
                            </div>
                        </div>
                    `
                } else {
                    // ‚úÖ FLEXION/EXTENSION: Mostrar solo lado activo con icono direccional
                    const sideIcon = romSide === 'derecho' ? '<i class="bi bi-arrow-right-circle-fill" style="color: #FFD700;"></i>' : 
                                     romSide === 'izquierdo' ? '<i class="bi bi-arrow-left-circle-fill" style="color: #FF6B6B;"></i>' : 
                                     romSide === 'ambos' ? '<i class="bi bi-arrow-left-right" style="color: #00D4FF;"></i>' : ''
                    const sideText = romSide !== 'ninguno' ? ` <span style="color: var(--biomech-text-secondary); font-size: 0.85em;">${sideIcon} ${romSide.charAt(0).toUpperCase() + romSide.slice(1)}</span>` : ''
                    
                    romDisplayHTML = `
                        <strong style="color: var(--biomech-cyan); font-size: 1.1rem; text-shadow: 0 0 8px rgba(0, 212, 255, 0.3);">
                            ROM: ${maxRom.toFixed(1)}¬∞
                        </strong>
                        ${sideText}
                    `
                }
                
                historyHTML += `
                    <div style="background: rgba(15, 23, 42, 0.6); 
                                border: 1px solid rgba(0, 212, 255, 0.2); 
                                border-radius: 12px; 
                                padding: 1rem; 
                                margin-bottom: 0.75rem;
                                transition: all 0.3s ease;
                                cursor: pointer;"
                         onmouseover="this.style.borderColor='rgba(0, 212, 255, 0.4)'; this.style.transform='translateX(5px)'; this.style.boxShadow='0 4px 12px rgba(0, 212, 255, 0.2)'"
                         onmouseout="this.style.borderColor='rgba(0, 212, 255, 0.2)'; this.style.transform='translateX(0)'; this.style.boxShadow='none'">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="flex: 1;">
                                <div style="color: var(--biomech-text-secondary); font-size: 0.85rem; margin-bottom: 0.3rem;">
                                    <i class="bi bi-calendar3"></i> ${date} <span style="margin-left: 0.5rem;"><i class="bi bi-clock"></i> ${time}</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap;">
                                    ${romDisplayHTML}
                                    <span style="background: ${style.bg}; 
                                                 color: ${style.text}; 
                                                 border: 1px solid ${style.border}; 
                                                 padding: 0.25rem 0.75rem; 
                                                 border-radius: 20px; 
                                                 font-size: 0.8rem; 
                                                 font-weight: 600;
                                                 text-shadow: ${style.shadow};">
                                        ${classification}
                                    </span>
                                </div>
                            </div>
                            <div style="text-align: right; min-width: 100px;">
                                <div style="color: var(--biomech-green); font-weight: 600; font-size: 0.95rem; margin-bottom: 0.2rem;">
                                    <i class="bi bi-star-fill"></i> ${quality.toFixed(0)}%
                                </div>
                                <div style="color: var(--biomech-text-secondary); font-size: 0.85rem;">
                                    <i class="bi bi-stopwatch"></i> ${duration}s
                                </div>
                            </div>
                        </div>
                    </div>
                `
            } catch (itemError) {
                console.warn('‚ö†Ô∏è Error procesando item historial:', itemError)
            }
        })
        
        historyContainer.innerHTML = historyHTML
        
        // Actualizar estad√≠sticas
        updateROMStats(data.history)
        
    } catch (error) {
        console.error('‚ùå Error cargando historial:', error)
        // üõ°Ô∏è NO ROMPER LA UI
        document.getElementById('analysisHistory').innerHTML = '<p class="text-muted">Historial no disponible temporalmente</p>'
    } finally {
        // üõ°Ô∏è LIMPIAR FLAG SIEMPRE
        isLoadingHistory = false
    }
}

function updateROMStats(history) {
    if (history.length === 0) return
    
    const maxROMs = history.map(h => h.max_rom)
    const avgROM = maxROMs.reduce((a, b) => a + b, 0) / maxROMs.length
    const bestROM = Math.max(...maxROMs)
    const totalAnalyses = history.length
    
    const statsContainer = document.getElementById('romStats')
    statsContainer.innerHTML = `
        <div style="display: flex; flex-direction: column; gap: 1rem;">
            <!-- Mejor ROM -->
            <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(0, 212, 255, 0.1)); 
                        border: 1px solid rgba(16, 185, 129, 0.3); 
                        border-radius: 12px; 
                        padding: 1rem; 
                        text-align: center;
                        transition: all 0.3s ease;"
                 onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 8px 16px rgba(16, 185, 129, 0.3)'"
                 onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'">
                <div style="color: var(--biomech-green); font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 1px;">
                    <i class="bi bi-trophy-fill"></i> Mejor ROM
                </div>
                <div style="color: var(--biomech-cyan); font-size: 2rem; font-weight: 700; text-shadow: 0 0 15px rgba(0, 212, 255, 0.5);">
                    ${bestROM.toFixed(1)}¬∞
                </div>
            </div>
            
            <!-- Promedio -->
            <div style="background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(107, 70, 193, 0.1)); 
                        border: 1px solid rgba(0, 212, 255, 0.3); 
                        border-radius: 12px; 
                        padding: 1rem; 
                        text-align: center;
                        transition: all 0.3s ease;"
                 onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 8px 16px rgba(0, 212, 255, 0.3)'"
                 onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'">
                <div style="color: var(--biomech-cyan); font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 1px;">
                    <i class="bi bi-graph-up"></i> Promedio
                </div>
                <div style="color: var(--biomech-purple); font-size: 1.75rem; font-weight: 700; text-shadow: 0 0 15px rgba(107, 70, 193, 0.5);">
                    ${avgROM.toFixed(1)}¬∞
                </div>
            </div>
            
            <!-- Total An√°lisis -->
            <div style="background: rgba(107, 70, 193, 0.1); 
                        border: 1px solid rgba(107, 70, 193, 0.3); 
                        border-radius: 12px; 
                        padding: 0.75rem; 
                        text-align: center;">
                <div style="color: var(--biomech-text-secondary); font-size: 0.85rem;">
                    <i class="bi bi-bar-chart-fill"></i> Total de An√°lisis
                </div>
                <div style="color: var(--biomech-text-primary); font-size: 1.25rem; font-weight: 600; margin-top: 0.25rem;">
                    ${totalAnalyses}
                </div>
            </div>
        </div>
    `
}

// =============================================================================
// ‚öôÔ∏è FUNCIONES CONFIGURACION CAMARA
// =============================================================================

/**
 * Abrir modal de configuracion de camara
 */
function openCameraSettings() {
    console.log('üîì Abriendo configuraci√≥n de c√°mara...');
    const modal = document.getElementById('cameraSettingsModal');
    if (modal) {
        modal.classList.add('active');
        console.log('‚úÖ Modal activado (clase .active agregada)');
        loadCurrentCameraSettings();
        loadCameraList();
    } else {
        console.error('‚ùå Modal de configuraci√≥n de c√°mara no encontrado en el DOM');
    }
}

/**
 * Cerrar modal de configuracion
 */
function closeCameraSettings() {
    const modal = document.getElementById('cameraSettingsModal');
    if (modal) {
        modal.classList.remove('active');
    } else {
        console.error('‚ùå Modal no encontrado en el DOM');
    }
}

/**
 * üîä Toggle audio guide (mute/unmute)
 */
function toggleAudioGuide() {
    if (!window.audioGuide) {
        console.warn('‚ö†Ô∏è AudioGuideSystem no disponible');
        return;
    }
    
    const isEnabled = window.audioGuide.toggleMute();
    const btn = document.getElementById('audioToggleBtn');
    const icon = document.getElementById('audioIcon');
    
    if (btn && icon) {
        if (isEnabled) {
            // Audio ON
            btn.classList.remove('muted');
            icon.className = 'bi bi-volume-up-fill';
            btn.title = 'Desactivar Audio';
        } else {
            // Audio OFF (muted)
            btn.classList.add('muted');
            icon.className = 'bi bi-volume-mute-fill';
            btn.title = 'Activar Audio';
        }
    }
}

// =============================================================================
// üîç DEBUG PANEL FUNCTIONS (SOLO ADMIN)
// =============================================================================

/**
 * üîç Toggle del panel de debug
 */
function toggleDebugPanel() {
    const panel = document.getElementById('debugPanel');
    if (!panel) return;
    
    if (panel.style.display === 'none' || !panel.style.display) {
        panel.style.display = 'block';
        // Actualizar info del segmento actual
        updateDebugInfo();
    } else {
        panel.style.display = 'none';
    }
}

/**
 * üîç Actualizar informaci√≥n del segmento/ejercicio actual
 */
function updateDebugInfo() {
    const segmentSpan = document.getElementById('debugSegment');
    const exerciseSpan = document.getElementById('debugExercise');
    
    if (segmentSpan && typeof EXERCISE_CONFIG !== 'undefined') {
        segmentSpan.textContent = EXERCISE_CONFIG.segment || '-';
    }
    
    if (exerciseSpan && typeof EXERCISE_CONFIG !== 'undefined') {
        exerciseSpan.textContent = EXERCISE_CONFIG.exercise || '-';
    }
}

/**
 * üîç Toggle del modo debug (activar/desactivar)
 */
async function toggleDebugMode() {
    if (typeof EXERCISE_CONFIG === 'undefined') {
        alert('‚ö†Ô∏è No hay ejercicio activo');
        return;
    }
    
    const statusIcon = document.getElementById('debugStatusIcon');
    const statusText = document.getElementById('debugStatusText');
    const toggleBtn = document.getElementById('debugToggleButton');
    const captureBtn = document.getElementById('captureBtn');
    const captureManualBtn = document.getElementById('captureManualBtn');
    
    const isActive = statusIcon.style.color === 'rgb(76, 175, 80)'; // Verde
    
    try {
        if (isActive) {
            // DESACTIVAR
            const response = await fetch(`/api/debug/disable/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'}
            });
            
            const data = await response.json();
            
            if (data.success) {
                statusIcon.style.color = '#666';
                statusText.textContent = 'Debug Inactivo';
                toggleBtn.innerHTML = '<i class="bi bi-play-fill"></i> Activar Debug';
                toggleBtn.className = 'btn btn-sm btn-outline-primary';
                captureBtn.disabled = true;
                captureManualBtn.disabled = true;
                
                console.log('‚úÖ Debug desactivado');
            } else {
                alert('‚ùå Error: ' + data.error);
            }
        } else {
            // ACTIVAR
            const response = await fetch(`/api/debug/enable/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'}
            });
            
            const data = await response.json();
            
            if (data.success) {
                statusIcon.style.color = '#4CAF50'; // Verde
                statusText.textContent = 'Debug Activo';
                toggleBtn.innerHTML = '<i class="bi bi-stop-fill"></i> Desactivar Debug';
                toggleBtn.className = 'btn btn-sm btn-outline-danger';
                captureBtn.disabled = false;
                captureManualBtn.disabled = false;
                
                console.log('üîç Debug activado');
            } else {
                alert('‚ùå Error: ' + data.error);
            }
        }
    } catch (error) {
        console.error('‚ùå Error en toggleDebugMode:', error);
        alert('Error de conexi√≥n: ' + error.message);
    }
}

/**
 * üì∏ Capturar snapshot sin √°ngulo manual
 */
async function captureDebugSnapshot() {
    if (typeof EXERCISE_CONFIG === 'undefined') {
        alert('‚ö†Ô∏è No hay ejercicio activo');
        return;
    }
    
    try {
        const response = await fetch(`/api/debug/capture/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'}
        });
        
        const data = await response.json();
        
        if (data.success) {
            displayDebugResult(data);
            console.log('üì∏ Snapshot capturado:', data);
        } else {
            // Mejorar mensaje de error
            let errorMsg = data.message || 'Error desconocido';
            if (errorMsg.includes('No hay datos de debug disponibles')) {
                errorMsg = '‚ö†Ô∏è No hay datos disponibles.\n\nAseg√∫rate de:\n1. Tener debug mode ACTIVO\n2. Haber INICIADO el an√°lisis\n3. Que haya una pose detectada en pantalla';
            }
            alert('‚ùå Error: ' + errorMsg);
        }
    } catch (error) {
        console.error('‚ùå Error capturando snapshot:', error);
        alert('Error de conexi√≥n: ' + error.message);
    }
}

/**
 * üìè Capturar snapshot con √°ngulo manual del goni√≥metro
 */
async function captureWithManualAngle() {
    if (typeof EXERCISE_CONFIG === 'undefined') {
        alert('‚ö†Ô∏è No hay ejercicio activo');
        return;
    }
    
    // Pedir √°ngulo manual al usuario
    const manualAngle = prompt('Ingresa el √°ngulo medido con el goni√≥metro f√≠sico (en grados):');
    
    if (manualAngle === null) {
        return; // Usuario cancel√≥
    }
    
    const angle = parseFloat(manualAngle);
    
    if (isNaN(angle) || angle < 0 || angle > 360) {
        alert('‚ö†Ô∏è √Ångulo inv√°lido. Debe estar entre 0 y 360 grados.');
        return;
    }
    
    try {
        const response = await fetch(`/api/debug/capture/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ manual_angle: angle })
        });
        
        const data = await response.json();
        
        if (data.success) {
            displayDebugResult(data, angle);
            console.log('üì∏ Snapshot capturado con √°ngulo manual:', data);
        } else {
            // Mejorar mensaje de error
            let errorMsg = data.message || 'Error desconocido';
            if (errorMsg.includes('No hay datos de debug disponibles')) {
                errorMsg = '‚ö†Ô∏è No hay datos disponibles.\n\nAseg√∫rate de:\n1. Tener debug mode ACTIVO\n2. Haber INICIADO el an√°lisis\n3. Que haya una pose detectada en pantalla';
            }
            alert('‚ùå Error: ' + errorMsg);
        }
    } catch (error) {
        console.error('‚ùå Error capturando snapshot:', error);
        alert('Error de conexi√≥n: ' + error.message);
    }
}

/**
 * üìä Mostrar resultado del snapshot en el panel
 */
function displayDebugResult(data, manualAngle) {
    const resultDiv = document.getElementById('debugLastResult');
    const contentDiv = document.getElementById('debugResultContent');
    
    if (!resultDiv || !contentDiv) return;
    
    let html = `
        <div class="small">
            <strong>Archivo:</strong> ${data.filename || 'N/A'}<br>
            <strong>√Ångulo calculado:</strong> ${data.calculated_angle || 'N/A'}¬∞<br>
    `;
    
    if (data.manual_angle !== undefined && data.manual_angle !== null) {
        const errorClass = Math.abs(data.error_deg) > 5 ? 'text-danger' : 'text-success';
        html += `
            <strong>√Ångulo manual:</strong> ${data.manual_angle}¬∞<br>
            <strong class="${errorClass}">Error:</strong> ${data.error_deg.toFixed(2)}¬∞ (${data.error_percent.toFixed(1)}%)<br>
        `;
    }
    
    html += `
            <strong>Timestamp:</strong> ${data.timestamp || 'N/A'}
        </div>
    `;
    
    contentDiv.innerHTML = html;
    resultDiv.style.display = 'block';
    
    // Auto-scroll al resultado
    resultDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

/**
 * Cargar configuracion actual en el modal
 */
function loadCurrentCameraSettings() {
    if (!window.cameraSettings) {
        console.error('cameraSettings no disponible');
        return;
    }
    
    const settings = window.cameraSettings.getSettings();
    console.log('Configuracion actual:', settings);
    
    // Actualizar banner de configuracion actual
    document.getElementById('currentCameraName').textContent = settings.deviceLabel || 'Automatico';
    document.getElementById('currentResolution').textContent = settings.resolution.value;
    document.getElementById('currentFPS').textContent = settings.fps + ' fps';
    document.getElementById('currentQuality').textContent = settings.quality + '%';
    
    // Actualizar controles
    document.getElementById('cameraSelect').value = settings.deviceId || '';
    document.getElementById('resolutionSlider').value = ['360p', '480p', '720p', '1080p'].indexOf(settings.resolution.value);
    document.getElementById('fpsSlider').value = window.cameraSettings.FPS_OPTIONS.indexOf(settings.fps);
    document.getElementById('qualitySlider').value = window.cameraSettings.QUALITY_OPTIONS.indexOf(settings.quality);
    
    updateSliderDisplays();
    updateBandwidthIndicator();
}

/**
 * Cargar lista de camaras disponibles
 */
async function loadCameraList() {
    try {
        const cameras = await window.cameraSettings.getCameraList();
        const select = document.getElementById('cameraSelect');
        
        // Limpiar opciones actuales (excepto "Automatico")
        select.innerHTML = '<option value="">Automatico (por defecto)</option>';
        
        // Agregar cada camara
        cameras.forEach(camera => {
            const option = document.createElement('option');
            option.value = camera.deviceId;
            option.textContent = camera.label;
            select.appendChild(option);
        });
        
        console.log(`${cameras.length} camaras cargadas`);
    } catch (error) {
        console.error('Error cargando lista de camaras:', error);
    }
}

/**
 * Aplicar preset rapido
 */
function applyPreset(presetName) {
    console.log('Aplicando preset:', presetName);
    
    if (!window.cameraSettings || !window.cameraSettings.CAMERA_PRESETS) {
        console.error('cameraSettings o CAMERA_PRESETS no disponible');
        return;
    }
    
    const preset = window.cameraSettings.CAMERA_PRESETS[presetName];
    
    if (!preset) {
        console.error('Preset no encontrado:', presetName);
        return;
    }
    
    // Si es preset "custom", solo mostrar sliders, no cambiar valores
    if (preset.custom) {
        console.log('Preset personalizado - mostrando controles manuales');
        return; // No actualizar sliders, dejar valores actuales
    }
    
    // Actualizar sliders con valores del preset
    // Nota: Los presets en el constructor usan estructura simple: {resolution: '480p', fps: 25, quality: 60}
    const resOptions = ['360p', '480p', '720p', '1080p'];
    
    const resolutionValue = preset.resolution;
    const fpsValue = preset.fps;
    const qualityValue = preset.quality;
    
    const resIndex = resOptions.indexOf(resolutionValue);
    const fpsIndex = window.cameraSettings.FPS_OPTIONS.indexOf(fpsValue);
    const qualityIndex = window.cameraSettings.QUALITY_OPTIONS.indexOf(qualityValue);
    
    if (resIndex === -1 || fpsIndex === -1 || qualityIndex === -1) {
        console.error('Valores de preset invalidos:', preset);
        console.error('Indices:', { resIndex, fpsIndex, qualityIndex });
        console.error('Buscando:', { resolutionValue, fpsValue, qualityValue });
        console.error('En arrays:', {
            resOptions,
            fpsOptions: window.cameraSettings.FPS_OPTIONS,
            qualityOptions: window.cameraSettings.QUALITY_OPTIONS
        });
        return;
    }
    
    document.getElementById('resolutionSlider').value = resIndex;
    document.getElementById('fpsSlider').value = fpsIndex;
    document.getElementById('qualitySlider').value = qualityIndex;
    
    updateSliderDisplays();
    updateBandwidthIndicator();
}

/**
 * Actualizar displays de sliders
 */
function updateSliderDisplays() {
    if (!window.cameraSettings) {
        console.error('cameraSettings no disponible');
        return;
    }
    
    const resSlider = document.getElementById('resolutionSlider');
    const fpsSlider = document.getElementById('fpsSlider');
    const qualitySlider = document.getElementById('qualitySlider');
    
    if (!resSlider || !fpsSlider || !qualitySlider) {
        console.error('Sliders no encontrados');
        return;
    }
    
    const resOptions = ['360p', '480p', '720p', '1080p'];
    const fpsOptions = window.cameraSettings.FPS_OPTIONS;
    const qualityOptions = window.cameraSettings.QUALITY_OPTIONS;
    
    const resDisplay = document.getElementById('resolutionDisplay');
    const fpsDisplay = document.getElementById('fpsDisplay');
    const qualityDisplay = document.getElementById('qualityDisplay');
    
    if (resDisplay) resDisplay.textContent = resOptions[resSlider.value];
    if (fpsDisplay) fpsDisplay.textContent = fpsOptions[fpsSlider.value];
    if (qualityDisplay) qualityDisplay.textContent = qualityOptions[qualitySlider.value];
}

/**
 * Actualizar indicador de ancho de banda
 */
function updateBandwidthIndicator() {
    if (!window.cameraSettings) {
        console.error('cameraSettings no disponible');
        return;
    }
    
    const resSlider = document.getElementById('resolutionSlider');
    const fpsSlider = document.getElementById('fpsSlider');
    const qualitySlider = document.getElementById('qualitySlider');
    
    if (!resSlider || !fpsSlider || !qualitySlider) {
        console.error('Sliders no encontrados');
        return;
    }
    
    const resOptions = ['360p', '480p', '720p', '1080p'];
    const fpsOptions = window.cameraSettings.FPS_OPTIONS;
    const qualityOptions = window.cameraSettings.QUALITY_OPTIONS;
    
    const resolutionValue = resOptions[resSlider.value];
    const fpsValue = fpsOptions[fpsSlider.value];
    const qualityValue = qualityOptions[qualitySlider.value];
    
    // calculateBandwidth espera objeto resolution con propiedad value
    const bandwidth = window.cameraSettings.calculateBandwidth(
        { value: resolutionValue },
        fpsValue,
        qualityValue
    );
    
    const bandwidthValue = document.getElementById('bandwidthValue');
    const bandwidthBar = document.getElementById('bandwidthBar');
    const bandwidthLabel = document.getElementById('bandwidthLabel');
    
    if (bandwidthValue) {
        bandwidthValue.textContent = bandwidth.bandwidthMbps;
    }
    
    if (bandwidthBar) {
        // Calcular porcentaje (10 Mbps = 100%)
        const percentage = Math.min((parseFloat(bandwidth.bandwidthMbps) / 10) * 100, 100);
        bandwidthBar.style.width = percentage + '%';
        
        // Color segun nivel
        if (bandwidth.level === 'low') {
            bandwidthBar.style.background = 'var(--biomech-green)';
        } else if (bandwidth.level === 'medium') {
            bandwidthBar.style.background = 'var(--biomech-cyan)';
        } else if (bandwidth.level === 'high') {
            bandwidthBar.style.background = 'var(--biomech-orange)';
        } else {
            bandwidthBar.style.background = 'var(--biomech-red)';
        }
    }
    
    if (bandwidthLabel) {
        const labels = {
            'low': '(Red lenta)',
            'medium': '(Red media)',
            'high': '(Red rapida)',
            'extreme': '(Red muy rapida)'
        };
        bandwidthLabel.textContent = labels[bandwidth.level] || '';
    }
}

/**
 * Actualizar warnings de configuracion
 */
function updateWarnings(bandwidth) {
    const warningsContainer = document.getElementById('settingsWarnings');
    const warnings = window.cameraSettings.validateConfiguration({
        resolution: ['360p', '480p', '720p', '1080p'][document.getElementById('resolutionSlider').value],
        fps: window.cameraSettings.FPS_OPTIONS[document.getElementById('fpsSlider').value],
        quality: window.cameraSettings.QUALITY_OPTIONS[document.getElementById('qualitySlider').value]
    });
    
    if (warnings.length === 0) {
        warningsContainer.innerHTML = '<div class="warning-item success"><i class="bi bi-check-circle"></i> Configuracion optima</div>';
    } else {
        warningsContainer.innerHTML = warnings.map(w => 
            `<div class="warning-item ${w.level}"><i class="bi bi-${w.level === 'warning' ? 'exclamation-triangle' : 'info-circle'}"></i> ${w.message}</div>`
        ).join('');
    }
}

/**
 * Restablecer valores por defecto
 */
function resetToDefaults() {
    if (!confirm('¬øRestablecer configuracion a valores por defecto?')) {
        return;
    }
    
    const defaults = window.cameraSettings.getDefaultSettings();
    
    document.getElementById('cameraSelect').value = '';
    document.getElementById('resolutionSlider').value = ['360p', '480p', '720p', '1080p'].indexOf(defaults.resolution.value);
    document.getElementById('fpsSlider').value = window.cameraSettings.FPS_OPTIONS.indexOf(defaults.fps);
    document.getElementById('qualitySlider').value = window.cameraSettings.QUALITY_OPTIONS.indexOf(defaults.quality);
    
    updateSliderDisplays();
    updateBandwidthIndicator();
    
    console.log('Configuracion restablecida a defaults');
}

/**
 * Aplicar y cerrar configuracion
 */
async function applyCameraSettings() {
    console.log('üíæ Aplicando nueva configuraci√≥n de c√°mara...');
    
    const cameraSelect = document.getElementById('cameraSelect');
    const resSlider = document.getElementById('resolutionSlider');
    const fpsSlider = document.getElementById('fpsSlider');
    const qualitySlider = document.getElementById('qualitySlider');
    
    const resOptions = ['360p', '480p', '720p', '1080p'];
    const resolutionValue = resOptions[resSlider.value];
    const resolutionMap = window.cameraSettings.RESOLUTION_OPTIONS;
    
    // üîß FIX: Convertir deviceId a n√∫mero entero, NO string
    let deviceId = cameraSelect.value;
    if (deviceId && deviceId !== 'auto' && deviceId !== 'undefined') {
        deviceId = parseInt(deviceId, 10); // Convertir a n√∫mero
        if (isNaN(deviceId)) {
            console.warn('‚ö†Ô∏è deviceId inv√°lido, usando null');
            deviceId = null;
        }
    } else {
        deviceId = null; // Auto-detecci√≥n
    }
    
    const newSettings = {
        deviceId: deviceId, // ‚úÖ Ahora es n√∫mero o null
        deviceLabel: cameraSelect.options[cameraSelect.selectedIndex].text,
        resolution: {
            value: resolutionValue,
            width: resolutionMap[resolutionValue].width,
            height: resolutionMap[resolutionValue].height
        },
        fps: window.cameraSettings.FPS_OPTIONS[fpsSlider.value],
        quality: window.cameraSettings.QUALITY_OPTIONS[qualitySlider.value],
        preset: 'custom'
    };
    
    console.log('üìã Nueva configuraci√≥n preparada:', newSettings);
    
    // Guardar en LocalStorage
    console.log('üíæ Guardando en LocalStorage...');
    const saved = window.cameraSettings.saveSettings(newSettings);
    
    if (!saved) {
        console.error('‚ùå Error guardando configuraci√≥n');
        alert('‚ùå Error guardando configuraci√≥n. Verifica los valores.');
        return;
    }
    console.log('‚úÖ Configuraci√≥n guardada en LocalStorage');
    
    // ÔøΩ BACKUP EN COOKIE para InPrivate/Incognito mode
    if (newSettings.deviceId !== null) {
        document.cookie = `biomech_camera=${newSettings.deviceId}; path=/; max-age=86400`; // 24 horas
        document.cookie = `biomech_camera_label=${encodeURIComponent(newSettings.deviceLabel)}; path=/; max-age=86400`;
        console.log('üç™ Backup en cookie creado:', newSettings.deviceId);
    }
    
    // ÔøΩüéØ ACTUALIZAR selectedCameraInfo para que pr√≥ximo an√°lisis use esta c√°mara
    if (newSettings.deviceId) {
        console.log('üéØ Actualizando selectedCameraInfo con nueva c√°mara:', newSettings.deviceLabel);
        // Preservar estructura para que startAnalysis() la reconozca
        selectedCameraInfo = {
            success: true,
            pythonCameraId: newSettings.deviceId,
            jsDeviceId: newSettings.deviceId,
            label: newSettings.deviceLabel,
            deviceType: 'user_selected',
            source: 'Manual'
        };
    } else {
        selectedCameraInfo = null; // Forzar redetecci√≥n
    }
    
    // Actualizar handler si existe
    if (window.clientCameraHandler) {
        window.clientCameraHandler.updateSettings(newSettings);
        
        // Si hay una c√°mara activa, reiniciarla para aplicar cambios
        if (window.clientCameraHandler.isStreaming) {
            // Guardar estado actual
            const currentSegment = CURRENT_CONFIG.segment;
            const currentExercise = CURRENT_CONFIG.exercise;
            
            // Detener c√°mara actual
            window.clientCameraHandler.stopCamera();
            
            // Esperar un momento para liberar recursos
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Reiniciar con nueva configuraci√≥n
            try {
                await window.clientCameraHandler.startCamera(currentSegment, currentExercise, newSettings.deviceId);
                alert('‚úÖ Configuraci√≥n aplicada! La c√°mara se ha reiniciado con los nuevos valores.');
            } catch (error) {
                console.error('‚ùå Error reiniciando c√°mara:', error);
                alert('‚ö†Ô∏è Configuraci√≥n guardada, pero hubo un error reiniciando la c√°mara. Inicia el an√°lisis nuevamente.');
            }
        } else {
            // C√°mara no activa - solo guardar
            alert('‚úÖ Configuraci√≥n guardada! Los cambios se aplicar√°n en el pr√≥ximo inicio de an√°lisis.');
        }
    } else {
        // Handler no existe todav√≠a
        alert('‚úÖ Configuraci√≥n guardada! Los cambios se aplicar√°n cuando inicies el an√°lisis.');
    }
    
    // Cerrar modal
    console.log('üîí Cerrando modal despu√©s de aplicar configuraci√≥n...');
    closeCameraSettings();
    console.log('‚úÖ Proceso completado exitosamente');
}

// =============================================================================
// üöÄ INICIALIZACI√ìN
// =============================================================================

document.addEventListener('DOMContentLoaded', function() {
    console.log('ÔøΩüö®üö® DOMContentLoaded EJECUTADO üö®üö®üö®');
    
    try {
        console.log('ÔøΩüì± Sistema cargado')
        console.log('üéØ Configuraci√≥n:', EXERCISE_CONFIG)
        
        console.log('üîç Verificando funciones updateStatus y updateStreamStatus...');
        
        if (typeof updateStatus === 'function') {
            console.log('‚úÖ updateStatus est√° disponible');
            updateStatus('Sistema listo', 'ready')
        } else {
            console.error('‚ùå updateStatus NO est√° disponible');
        }
        
        // üìä CARGAR HISTORIAL AL INICIAR
        setTimeout(() => {
            loadAnalysisHistory()
        }, 1000)
        
        // üß≠ INICIALIZAR NAVEGACI√ìN DE EJERCICIOS
        updateNavigationUI()
        
        if (typeof updateStreamStatus === 'function') {
            console.log('‚úÖ updateStreamStatus est√° disponible');
            updateStreamStatus('Inactivo')
        } else {
            console.error('‚ùå updateStreamStatus NO est√° disponible');
        }
        
        // üöÄ ASIGNAR EVENT LISTENER AL BOT√ìN (evita timing issues)
        const startBtn = document.getElementById('startAnalysisBtn');
        if (startBtn) {
            startBtn.addEventListener('click', function() {
                console.log('üéØ Bot√≥n clicked - verificando startAnalysis...');
                if (typeof startAnalysis === 'function') {
                    console.log('‚úÖ startAnalysis disponible, ejecutando...');
                    startAnalysis();
                } else {
                    console.error('‚ùå startAnalysis NO est√° disponible a√∫n');
                    // Retry despu√©s de un momento
                    setTimeout(() => {
                        if (typeof startAnalysis === 'function') {
                            console.log('‚úÖ startAnalysis disponible en retry, ejecutando...');
                            startAnalysis();
                        } else {
                            console.error('‚ùå startAnalysis sigue no disponible');
                        }
                    }, 1000);
                }
            });
            console.log('‚úÖ Event listener asignado al bot√≥n');
        } else {
            console.error('‚ùå No se encontr√≥ startAnalysisBtn');
        }
        
        // ‚öôÔ∏è INICIALIZAR EVENT LISTENERS PARA SLIDERS DE CONFIGURACION
        const resSlider = document.getElementById('resolutionSlider');
        const fpsSlider = document.getElementById('fpsSlider');
        const qualitySlider = document.getElementById('qualitySlider');
        
        if (resSlider && fpsSlider && qualitySlider) {
            resSlider.addEventListener('change', () => {
                updateSliderDisplays();
                updateBandwidthIndicator();
            });
            
            fpsSlider.addEventListener('input', () => {
                updateSliderDisplays();
                updateBandwidthIndicator();
            });
            
            qualitySlider.addEventListener('input', () => {
                updateSliderDisplays();
                updateBandwidthIndicator();
            });
            
            console.log('‚úÖ Event listeners de sliders configurados');
        } else {
            console.error('‚ùå No se encontraron sliders:', {resSlider, fpsSlider, qualitySlider});
        }
        
        // ‚öôÔ∏è INICIALIZAR EVENT LISTENERS PARA BOTONES DE PRESETS
        const presetButtons = document.querySelectorAll('.preset-btn');
        presetButtons.forEach(btn => {
            btn.addEventListener('click', function() {
                const presetName = this.getAttribute('data-preset');
                console.log('Preset clicked:', presetName);
                
                // Remover active de todos
                presetButtons.forEach(b => b.classList.remove('preset-active'));
                // Agregar active al clickeado
                this.classList.add('preset-active');
                
                // Aplicar preset
                applyPreset(presetName);
                
                // Mostrar/ocultar configuracion personalizada
                const customSettings = document.getElementById('customSettings');
                if (presetName === 'custom') {
                    customSettings.style.display = 'block';
                } else {
                    customSettings.style.display = 'none';
                }
            });
        });
        
        if (presetButtons.length > 0) {
            console.log('‚úÖ Event listeners de presets configurados:', presetButtons.length);
        } else {
            console.error('‚ùå No se encontraron botones de presets');
        }
        
        console.log('‚úÖ DOMContentLoaded completado exitosamente');
        
    } catch (error) {
        console.error('‚ùå ERROR CR√çTICO en DOMContentLoaded:', error);
        console.error('‚ùå Stack trace:', error.stack);
    }
})

// =============================================================================
// üßπ CLEANUP AL SALIR DE LA P√ÅGINA
// =============================================================================

// üÜï Funci√≥n compartida de limpieza
function cleanupBeforeExit(eventType) {
    console.log(`üö™ ${eventType}: Limpiando recursos antes de salir...`);
    
    // üîá DETENER AUDIO INMEDIATAMENTE
    if (window.speechSynthesis) {
        window.speechSynthesis.cancel();
        console.log('üîá Audio cancelado en ' + eventType);
    }
    
    // üõë DETENER STREAM SI EST√Å ACTIVO
    if (analysisState === 'running' || analysisState === 'loading') {
        console.log('üõë Deteniendo stream activo en ' + eventType);
        
        // Marcar como detenido para prevenir reconexiones
        analysisState = 'stopped';
        
        // Detener stream en el servidor
        const stopUrl = `/api/stop_stream/${EXERCISE_CONFIG.segment}/${EXERCISE_CONFIG.exercise}`;
        
        // Usar sendBeacon para env√≠o confiable durante unload
        if (navigator.sendBeacon) {
            navigator.sendBeacon(stopUrl, JSON.stringify({}));
            console.log('üì° sendBeacon enviado para detener stream');
        } else {
            // Fallback: fetch s√≠ncrono (no recomendado pero funciona)
            fetch(stopUrl, { 
                method: 'POST',
                keepalive: true  // Asegurar que la petici√≥n se complete
            }).catch(err => console.warn('‚ö†Ô∏è Error en stop stream:', err));
        }
    }
    
    // üé• DETENER C√ÅMARA DEL CLIENTE
    if (window.clientCameraHandler && window.clientCameraHandler.isStreaming) {
        console.log('üì∑ Deteniendo c√°mara del cliente en ' + eventType);
        window.clientCameraHandler.stopCamera();
    }
    
    // üõë LIMPIAR TODOS LOS INTERVALS
    if (typeof activeIntervals !== 'undefined') {
        console.log(`üõë Limpiando ${activeIntervals.size} intervals en ` + eventType);
        activeIntervals.forEach(intervalId => clearInterval(intervalId));
        activeIntervals.clear();
    }
    
    // üîä DETENER AUDIO GUIDE SYSTEM
    if (window.audioGuideSystem && typeof window.audioGuideSystem.stop === 'function') {
        window.audioGuideSystem.stop();
        console.log('üîä AudioGuideSystem detenido en ' + eventType);
    }
}

// üÜï M√öLTIPLES EVENTOS PARA M√ÅXIMA COMPATIBILIDAD
window.addEventListener('beforeunload', function(event) {
    cleanupBeforeExit('beforeunload');
});

// üÜï pagehide - M√°s confiable que beforeunload en m√≥viles
window.addEventListener('pagehide', function(event) {
    cleanupBeforeExit('pagehide');
});

// üÜï visibilitychange - Detecta cuando se oculta la pesta√±a
document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
        // Solo detener audio cuando se oculta, no el stream completo
        if (window.speechSynthesis) {
            window.speechSynthesis.cancel();
            console.log('üîá Audio cancelado (tab oculto)');
        }
    }
});

// =============================================================================
// üéØ MEN√ö DESPLEGABLE DE EJERCICIOS
// =============================================================================

function initializeExerciseDropdown() {
    const dropdownBtn = document.getElementById('exerciseMenuBtn');
    const dropdownMenu = document.getElementById('exerciseDropdownMenu');
    const dropdownItems = document.getElementById('exerciseDropdownItems');
    
    if (!dropdownBtn || !dropdownMenu || !dropdownItems) return;
    
    // Poblar men√∫ con ejercicios disponibles
    populateExerciseMenu();
    
    // Toggle dropdown
    dropdownBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const isVisible = dropdownMenu.style.display === 'block';
        dropdownMenu.style.display = isVisible ? 'none' : 'block';
    });
    
    // Cerrar al hacer click fuera
    document.addEventListener('click', (e) => {
        if (!dropdownBtn.contains(e.target) && !dropdownMenu.contains(e.target)) {
            dropdownMenu.style.display = 'none';
        }
    });
    
    console.log('‚úÖ Men√∫ desplegable de ejercicios inicializado');
}

function populateExerciseMenu() {
    const dropdownItems = document.getElementById('exerciseDropdownItems');
    if (!dropdownItems || !EXERCISE_CONFIG) return;
    
    // üéØ LISTA COMPLETA de TODOS los ejercicios de TODOS los segmentos
    const allExercises = {
        'shoulder': {
            name: 'Hombro',
            exercises: ['flexion', 'extension', 'abduction']
        },
        'elbow': {
            name: 'Codo',
            exercises: ['flexion', 'extension', 'overhead_extension']
        },
        'hip': {
            name: 'Cadera',
            exercises: ['flexion', 'abduction', 'adduction']
        },
        'knee': {
            name: 'Rodilla',
            exercises: ['flexion', 'extension']
        },
        'ankle': {
            name: 'Tobillo',
            exercises: ['plantar_flexion', 'dorsiflexion', 'inversion']
        }
    };
    
    const currentExercise = '{{ exercise_config.exercise }}';
    const currentJoint = '{{ joint_type }}';
    
    let html = '';
    
    // Generar men√∫ agrupado por segmento
    Object.entries(allExercises).forEach(([jointType, jointData]) => {
        // Header del segmento
        html += `
            <div class="dropdown-segment-header">${jointData.name}</div>
        `;
        
        // Ejercicios del segmento
        jointData.exercises.forEach(exercise => {
            const isActive = exercise === currentExercise && jointType === currentJoint;
            const exerciseName = exercise.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            
            html += `
                <a href="/analysis/${jointType}/${exercise}" 
                   class="dropdown-item ${isActive ? 'active' : ''}">
                    <i class="bi ${isActive ? 'bi-check-circle-fill' : 'bi-circle'}"></i>
                    <span>${exerciseName}</span>
                </a>
            `;
        });
    });
    
    dropdownItems.innerHTML = html;
    
    // Actualizar indicador del bot√≥n con el segmento actual
    const currentJointName = allExercises[currentJoint]?.name || 'Ejercicios';
    document.getElementById('currentExerciseIndicator').textContent = currentJointName;
}

// =============================================================================
// üîΩ BOT√ìN DE SCROLL FLOTANTE
// =============================================================================

function initializeScrollIndicator() {
    const scrollBtn = document.getElementById('scrollDownBtn');
    if (!scrollBtn) return;
    
    // Mostrar/ocultar seg√∫n posici√≥n de scroll
    function checkScrollPosition() {
        const windowHeight = window.innerHeight;
        const documentHeight = document.documentElement.scrollHeight;
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        
        // Mostrar solo si hay m√°s de 200px de contenido oculto abajo
        const hiddenContentBelow = documentHeight - (scrollTop + windowHeight);
        
        if (hiddenContentBelow > 200) {
            scrollBtn.style.display = 'flex';
        } else {
            scrollBtn.style.display = 'none';
        }
    }
    
    // Click para scroll suave hasta el final
    scrollBtn.addEventListener('click', () => {
        window.scrollTo({
            top: document.documentElement.scrollHeight,
            behavior: 'smooth'
        });
    });
    
    // Verificar posici√≥n en scroll
    window.addEventListener('scroll', checkScrollPosition);
    
    // Verificar posici√≥n inicial
    setTimeout(checkScrollPosition, 500); // Esperar a que cargue todo
    
    console.log('‚úÖ Indicador de scroll inicializado');
}

// Inicializar al cargar
document.addEventListener('DOMContentLoaded', () => {
    initializeExerciseDropdown();
    initializeScrollIndicator();
});

console.log('‚úÖ JavaScript cargado - SINTAXIS CORREGIDA')

</script>

<!-- ============================================================================
     ‚öôÔ∏è MODAL DE CONFIGURACION DE CAMARA
     ============================================================================ -->
{% include 'partials/camera_settings_modal.html' %}

{% endblock %}